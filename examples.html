<!DOCTYPE HTML>
<!--
	Spectral by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>MOAP Examples</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="assets/css/main.css" />
		<!--[if lte IE 8]><link rel="stylesheet" href="assets/css/ie8.css" /><![endif]-->
		<!--[if lte IE 9]><link rel="stylesheet" href="assets/css/ie9.css" /><![endif]-->
	</head>
	<body>

		<!-- Page Wrapper -->
			<div id="page-wrapper">

				<!-- Header -->
					<header id="header">
						<h1><a href="index.html">MOAP</a></h1>
						<nav id="nav">
							<ul>
								<li class="special">
									<a href="#menu" class="menuToggle"><span>Menu</span></a>
									<div id="menu">
										<ul>
											<li><a href="index.html">Home</a></li>
											<li><a href="getting_started.html">Getting Started</a></li>
											<li><a href="examples.html">Examples</a></li>
											<li><a href="about.html">About MOAP</a></li>
											<li><a href="contact.html">Contact Us</a></li>
										</ul>
									</div>
								</li>
							</ul>
						</nav>
					</header>

				<!-- Main -->
					<article id="main">
						<header>
							<h2>Examples</h2>
							<p>ABM: Already Been MOAPed</p>
						</header>
						<section class="wrapper style5">
							<div class="inner">
								<p class="c1 c4"><span></span></p><p class="c1 c4"><span></span></p><p class="c1 c8"><span class="c6"></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.a98yemkglr5y">Finding Even child (DONE)</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.rm8abvxycaez">Long Form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.7zowvtdyjnjf">Short form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.b5hbp2a1fv1g">Thought Process</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.mhwlt0q2gwd4">Pseudocode</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.bvp7boag3ws8">Finding Even child of two lists (DONE)</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.3kicp4791a4u">Long Form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.s1mwqpaj4y8o">Short Form</a></span><span class="c6">`</span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.l7hz5gbv4v3a">Thought process</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.wzc7pz6e9r33">Find two equal things in a list (POSSIBLE)</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.tlpupjpzu1r0">Long Form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.3y2nu9pqlhmo">Sorting (POSSIBLE?)</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.a3dabt92oepd">Short form</a></span></p><p class="c1 c13"><span class="c6"><a class="c10" href="#h.p7dub4opan3f">Form one</a></span></p><p class="c1 c13"><span class="c6"><a class="c10" href="#h.jb5ep6svfz6f">Form two</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.ajfj9dms6up1">Largest element (POSSIBLE)</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.ykxelgwumrd1">Long form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.905utygtgs6x">Short form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.ibsvfxsjarym">Thought process</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.ch8og6fbv04o">Two-sum (POSSIBLE)</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.npo5u7grbm14">Long form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.gdl09o5ucpuy">Short form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.6iy6u4h5bumr">Desired output</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.9v17f9ifgjbf">Thought process</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.4rg9tnzfq333">Shortest Pair Distance</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.kwk32xbjcike">Long form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.xqqyhtdo9qji">Short form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.e0bbjbbbn7rj">Thought Process</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.whfn0l5vwowe">Shortest Path in a Graph</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.8fh0fgqhutl2">Long form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.osfb5uvknpbf">Short Form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.4402vua757q">Projectile motion</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.i98ozycpien4">N-Queens</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.5lqycxyxv2jf">Thought Process</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.ng958bfkxamw">Short-Form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.gvtqu2a8oir7">Sum of a list (POSSIBLE)</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.sy0enja2o4he">Long form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.93x3yq9v46wm">Substring detection (maybe?)</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.i4icwal7jiae">Long Form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.y0vpckpigh43">Short Form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.1v0uo7kg8utd">Count Subarray</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.ob98gn95gqiv">Long Form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.wlbmfx6pniah">Short form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.ymvd1pvukrsx">Check Triangle</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.k0i1f3nqx7rk">Long Form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.o7bxi0p0zik9">Short Form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.82dfhw9ulzt7">Palindrome</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.ecf8gtffsnkr">Long Form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.c6m0jhohuz8y">Legal parentheses</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.u6bzhmpten38">Long Form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.zaj13mazaz1q">Permutations</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.5ughdnmrdj4">Long Form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.ra9fijbay6wj">Remove duplicates from a list</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.ni810ipad6e3">Long Form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.v315jai4dafd">List index equality</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.kl9aoust8acv">Long Form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.n8xdhar9s63g">Short Form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.hwbhjvu7riqg">Thought Process</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.xl12so75mfx2">List contains average of total list (POSSIBLE)</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.4r1xfgtx85d7">Short form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.orm013hwh0p8">Long form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.368wbtonu47c">Finding a Value in a Tree</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.nnybswy8lnff">Short form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.60985ze1kvgr">Long form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.a7cs0yk531mh">Find Subtrees</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.okl344upkqxr">Short form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.7o4v4cstuhna">Long Form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.ut8d3cupx2tx">Finding Deepest Leaf in a Tree</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.3q43fit4rgix">Long Form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.flh7pnzh9fbs">Short form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.uzn33ubgehlo">Find largest value in a tree</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.brkvo1ukeirn">Short form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.tzoih5fjkht9">long form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.pbr2zboo32eq">Optimal Bitontic Tour (https://en.wikipedia.org/wiki/Bitonic_tour)</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.27496j6do21e">Short form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.fs74lcim4oe">Determining if a Number is Prime</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.rxc763rae6vy">Short form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.jbuzrvr0a5jv">Long Form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.skt36vj02llq">Though Process</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.6ryqdfobe7b7">Pseudocode (?)</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.fbzge8ov0kt7">Finding a Sequence in an Array</a></span><span class="c6">s</span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.2c538r6q38em">Long form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.xe7t782jywy0">short form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.71mq0a5za0ug">Thought Process</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.hk2q1kv7xzgl">Pseudocode</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.dvyjz28ycyct">Searching for a value in array</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.wpzl69nyfdw6">Short Form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.5s2b31jrwr56">Long form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.uy2h712kmqry">Find duplicate entries in array</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.907c2no5s838">Short Form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.8cd23wzc4u9a">Long From</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.5b8p7vl5irgx">Find array index which contains itself</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.jngdf7cgijir">Long form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.7vhv239o18qw">Collapse edges in graph</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.hi674t9kj3qs">Long form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.2lcn6666zium">Stable Matching</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.pbm10h42vonj">Short form</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.u7hyykzdrml4">Train of thought (Brute Force)</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.n31jhu8mwdyz">Stable Roommate Problem</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.8jcac89im8za">Copy of a list</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.bpccl8wh4bkx">Short form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.ihkzhvws6cu">Sort a list by another list</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.5kbpyq43at3u">Short form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.d6eykp3u425s">Simple Knapsack</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.7bhvcuyzki1u">Short form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.xtbqcikn948c">Knapsack Problem</a></span></p><p class="c1 c2"><span class="c6"><a class="c10" href="#h.jgoisqufk06f">Short Form</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.s2htuetcvld">Scheduling to minimize lateness</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.ahvbb8b9c5l5">Rotating a 2d array</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.8rz15r2zqhyd">Adding elements to a sorted list</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.uvge8k39o8de">Determine if two objects are NOT in a list</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.ea258ox0faj2">Subset Sum</a></span></p><p class="c1 c8"><span class="c6"><a class="c10" href="#h.enty9248lob9">Cycle in a graph</a></span></p><p class="c1 c4"><span></span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.gs551zh9vacf"><span>things that aren&#39;t really in our scope but maybe should be:</span></h2><p class="c1"><span>printing things</span></p><p class="c1"><span>using simple operations like addition</span></p><h2 class="c0" id="h.a98yemkglr5y"><span>Finding Even child (DONE)</span></h2><p class="c1"><span>Find an even number in a list of numbers (I KNOW it&#39;s trivial, but we need something easy)</span></p><h3 class="c0" id="h.rm8abvxycaez"><span>Long Form</span></h3><p class="c1"><span>Given list&lt;int&gt; x; Find y st child(x,y) &amp; even(y)</span></p><h3 class="c0" id="h.7zowvtdyjnjf"><span>Short form</span></h3><p class="c1"><span>Given list&lt;int&gt; x, find y in x st even(y)</span></p><h3 class="c0" id="h.b5hbp2a1fv1g"><span>Thought Process</span></h3><p class="c1"><span>Given a st type_list(a); Find b st even(b) &amp; child(a,b)</span></p><p class="c1"><span>Given a,b st child(a,b) &amp; type_list(a); Test(even(b))</span></p><p class="c1"><span>Given a,b st even(b) &amp; child(a,b) &amp; type_list(a); Test(TRUE)</span></p><h3 class="c0" id="h.mhwlt0q2gwd4"><span>Pseudocode</span></h3><p class="c1"><span>foreach y in x</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if y%2 == 0</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return y</span></p><h2 class="c0" id="h.bvp7boag3ws8"><span>Finding Even child of two lists (DONE)</span></h2><h3 class="c0" id="h.3kicp4791a4u"><span>Long Form</span></h3><p class="c1"><span>Given list&lt;int&gt; x, list&lt;int&gt; z; Find y st child(x,y) &amp; child(z,y) &amp; even(y)</span></p><h3 class="c0" id="h.s1mwqpaj4y8o"><span>Short Form</span></h3><p class="c1"><span>Given list&lt;int&gt; x, list&lt;int&gt; z, find y in x,z st even(y)</span></p><h3 class="c0" id="h.l7hz5gbv4v3a"><span>Thought process</span></h3><p class="c1"><span>actual:</span></p><p class="c1"><span>Given list&lt;int&gt; a,list&lt;int&gt; b; Find c st child(a,c) &amp; child(b,c) &amp; even(c)</span></p><p class="c1"><span>Given list&lt;int&gt; a,list&lt;int&gt; b,c st child(b,c); Test(child(a,c) &amp; even(c))</span></p><p class="c1"><span>Given list&lt;int&gt; a,list&lt;int&gt; b,c st even(c) &amp; child(b,c); Test(child(a,c))</span></p><p class="c1"><span>Given list&lt;int&gt; a,list&lt;int&gt; b,c,d st child(a,d) &amp; even(c) &amp; child(b,c); Test(equal(c,d) &amp; child(a,c))</span></p><p class="c1"><span>Given list&lt;int&gt; a,list&lt;int&gt; b,c,d st equal(c,d) &amp; child(a,d) &amp; even(c) &amp; child(b,c); Test(TRUE)</span></p><p class="c1"><span>desired:</span></p><p class="c1"><span>Given list&lt;int&gt; a,list&lt;int&gt; b; Find c st child(a,c) &amp; child(b,c) &amp; even(c)</span></p><p class="c1"><span>Given list&lt;int&gt; a,list&lt;int&gt; b,c st child(b,c); Test(child(a,c) &amp; even(c))</span></p><p class="c1"><span>Given list&lt;int&gt; a,list&lt;int&gt; b,c st even(c) &amp; child(b,c); Test(child(a,c))</span></p><p class="c1"><span>Given list&lt;int&gt; a,list&lt;int&gt; b,c,d st child(a,d) &amp; even(c) &amp; child(b,c); Test(equal(c,d) &amp; child(a,c))</span></p><p class="c1 c4"><span><br></span></p><p class="c1"><span>OLD:</span></p><p class="c1"><span>Given list&lt;int&gt; x, list&lt;int&gt; z, find y in x,z st even(y)</span></p><p class="c1"><span>reduces to</span></p><p class="c1"><span>Given list&lt;int&gt; x, list&lt;int&gt; z, y in x, find y in z st even(y)</span></p><p class="c1"><span>reduces to</span></p><p class="c1"><span>Given list&lt;int&gt; x, list&lt;int&gt; z, y in x, y&#39; in z, find y&#39; st even(y&#39;) &amp; y==y&#39;</span></p><p class="c1"><span>reduces to</span></p><p class="c1"><span>Given list&lt;int&gt; x, list&lt;int&gt; z, y in x, y&#39; in z st y==y&#39;, find y&#39; st even(y&#39;)</span></p><p class="c1"><span>reduces to</span></p><p class="c1"><span>Given list&lt;int&gt; x, list&lt;int&gt; z, y in x, y&#39; in z st y==y&#39; &amp; even(y&#39;), find _ st TRUE</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.wzc7pz6e9r33"><span>Find two equal things in a list (POSSIBLE)</span></h2><p class="c1"><span>Given a list of things, find two things that are equal</span></p><h3 class="c0" id="h.tlpupjpzu1r0"><span>Long Form</span></h3><p class="c1"><span>Given list x; Find y,z st child(x,y) &amp; child(x,z) &amp; equal(y,z)</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.3y2nu9pqlhmo"><span>Sorting (POSSIBLE?)</span></h2><h3 class="c0" id="h.a3dabt92oepd"><span>Short form</span></h3><h4 class="c0" id="h.p7dub4opan3f"><span>Form one</span></h4><p class="c1"><span>Given list x, Find list y st permutation(x,y) &amp; sorted(y)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>sorted(x)-&gt;forall(i,j st index(x,i) &amp; index(x,j) &amp; lessThan(i,j) : lessThan(get(x,i), get(x,j)))</span></p><p class="c1"><span>permutation(x,y)-&gt;forall(z st child(x,z) : count(x,z) = count(y,z)) &amp; size(x) = size(y)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>count(a,b,c) -&gt; exists(c of d : child(a,d) &amp; equal(b,d))</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>//Dumb permutation</span></p><p class="c1"><span>//permutation(x,y)-&gt; forall(z st child(x,z) : child(y,z)) &amp; forall(z st child(y,z) : child(x,z))</span></p><h4 class="c0" id="h.jb5ep6svfz6f"><span>Form two</span></h4><p class="c1 c4"><span></span></p><p class="c1"><span>Subproblem to test first would be given an array, test if it is sortable</span></p><h2 class="c0" id="h.ajfj9dms6up1"><span>Largest element (POSSIBLE)</span></h2><p class="c1"><span>Given a list of numbers, find the largest one</span></p><h3 class="c0" id="h.ykxelgwumrd1"><span>Long form</span></h3><p class="c1"><span>Given list&lt;number&gt; x; Find z st child(x,z) &amp; forall(y : child(x,y)</span><span>&nbsp;-&gt; lessThanEqual(y,z))</span></p><h3 class="c0" id="h.905utygtgs6x"><span>Short form</span></h3><p class="c1"><span>Given list&lt;number&gt; x; Find z in x st z is maximized</span></p><h3 class="c0" id="h.ibsvfxsjarym"><span>Thought process</span></h3><p class="c1"><span>Given list x; Find y st child(x,y) &amp; forall(z st child(x,z) : lessThanEqual(z,y))</span></p><p class="c1"><span>Given list x; Find y st child(x,y) &amp; forall(z st child(x,z) : lessThanEqual(z,y))</span></p><p class="c1"><span>Given list x,y st child(x,y); Find forall(z st child(x,z) : lessThanEqual(z,y))</span></p><p class="c1"><span>Given list x,y st child(x,y) &amp; forall(z st child(x,z) : lessThanEqual(z,y));</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>foreach child y of x</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean nb = true;</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach child na of x</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if na &gt; y</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nb = false</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if nb == true</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [y]</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Notes:</span></p><p class="c1"><span>formulations:</span></p><ol class="c14 lst-kix_9626pxgp6jlg-0 start" start="1"><li class="c1 c7 c2"><span>x, dx : a(x) &amp; d(x,dx) &amp; forall(y,dy : !d(y,dy) &nbsp;| !a(y) | dx &lt;= dy)</span></li><li class="c1 c7 c2"><span>x : a(x) &amp; forall(y,dx,dy : !d(x,dx) | !d(y,dy) &nbsp;| !a(y) | dx &lt;= dy)</span></li></ol><ol class="c14 lst-kix_9626pxgp6jlg-1 start" start="1"><li class="c1 c7 c11"><span>Canonicalizes to (1)</span></li></ol><p class="c1 c4"><span></span></p><p class="c1"><span>If there is a quantifier whose subject is an ORing and one of the ored elements is a binary transitive</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For all the other terms, find if there exists a negated version of them outside of the quantifier</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c1 c4"><span></span></p><p class="c1 c4"><span></span></p><p class="c1"><span>V2:<br>Because less_than_equal is transitive, we know that we can just keep track of the greatest we find over one iteration.</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>This could be derived. Namely, when we&#39;re trying to satisfy</span></p><p class="c1"><span>&quot;forall(y st child(y,x) : less_than_equal(y,z))&quot;, we could do so by saying that when we save something it is greater than everything before it, and by the time we get to the end we&#39;ll have everything??</span></p><h2 class="c0" id="h.ch8og6fbv04o"><span>Two-sum (POSSIBLE)</span></h2><p class="c1"><span>Given a list of numbers, find two that sum to a given number </span></p><h3 class="c0" id="h.npo5u7grbm14"><span>Long form</span></h3><p class="c1"><span>Given list&lt;int&gt; x,int s; Find i,j st index(x,i) &amp; index(x,j) &amp; equal(plus(get(x,i),get(x,j)),s)</span></p><h3 class="c0" id="h.gdl09o5ucpuy"><span>Short form</span></h3><p class="c1"><span>Given list&lt;int&gt; x, int s, Find indices i,j in x st x[i] + x[j] = s</span></p><p class="c1"><span>could also be:</span></p><p class="c1"><span>Given list&lt;int&gt; x, int s, Find i,j in x st i + j = s</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.6iy6u4h5bumr"><span>Desired output</span></h3><p class="c1"><span>na = new Hashtable();</span></p><p class="c1"><span>foreach index i of x</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nb = x[i]</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;na.put(nb,i)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>foreach index i of x</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nb = x[i]</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc = s - nb</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if na.contains(nc)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nd = na</span><span>.get(nc)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [i,nd]</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><h3 class="c0" id="h.9v17f9ifgjbf"><span>Thought process</span></h3><p class="c1"><span>Get to:<br>foreach index i of x // Note this is the SECOND for-loop in the above pseudocode</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nb = x[i]</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//:::want to find some j for which index(x,j) &amp; get(x,j,xj) &amp; plus(nb,xj,s)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The easiest way to do this is to make a hashtable earlier that will keep track of this.</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Thoughts:</span></p><p class="c1"><span>The thing we want to check has to have some certain properties to it.</span></p><p class="c1"><span>The problem we want to give the hashtable declaration is:</span></p><p class="c1"><span>//Given list x; Find i,xi st index(x,i) &amp; get(x,i,xi)</span></p><p class="c1"><span>na = new Hashtable();</span></p><p class="c1"><span>foreach index i of x</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nb = x[i]</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;na.put(nb,i) // This is the &quot;return code&quot; for this problem</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.4rg9tnzfq333"><span>Shortest Pair Distance </span></h2><p class="c1"><span>Given a series of points, find the two that are closest together</span></p><h3 class="c0" id="h.kwk32xbjcike"><span>Long form</span></h3><p class="c1"><span>Given x st forall(na st child(x,na) : type_point(na)) &amp; type_list(x); Find a,b,na st child(x,a) &amp; child(x,b) &amp; distance(a,b,na) &amp; forall(c,d,nb st child(x,c) &amp; child(x,d) &amp; distance(c,d,nb) : lessThanEqual(na,nb))</span></p><h3 class="c0" id="h.xqqyhtdo9qji"><span>Short form</span></h3><p class="c1"><span>Given Set s of points, Find i,j in s st i!=j and distance(i,j) is minimized</span></p><p class="c1"><span>Given set&lt;point&gt; s; Find i,j st child(s,i) &amp; child(s,j) &amp; forall(k,t st child(s,k) &amp; child(s,t) : distance(k,t) &lt;= distance(i,j))</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Given list&lt;point&gt; x; Find a,b st child(x,a) &amp; child(x,b) &amp; forall(c,d st child(x,c) &amp; child(x,d) : lessThanEqual(distance(a,b),distance(c,d)))</span></p><h3 class="c0" id="h.e0bbjbbbn7rj"><span>Thought Process</span></h3><p class="c1"><span>Given list&lt;point&gt; x; Find a,b st child(x,a) &amp; child(x,b) &amp; forall(c,d st child(x,c) &amp; child(x,d) : lessThanEqual(distance(a,b),distance(c,d)))</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Can be reduced to the subproblems:</span></p><p class="c1"><span>Given list&lt;point&gt; x; Find a,b st child(x,a) &amp; child(x,b)</span></p><p class="c1"><span>and</span></p><p class="c1"><span>Given list&lt;point&gt; x,a,b,d,na,nb,nd st child(x,a) &amp; child(x,b) &amp; distance(a,b,d) &amp; child(x,na) &amp; child(x,nb) &amp; distance(na,nb,nd); Find !lessThanEqual(distance(a,b),distance(c,d))</span></p><p class="c1 c4"><span></span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.whfn0l5vwowe"><span>Shortest Path in a Graph</span></h2><h3 class="c0" id="h.8fh0fgqhutl2"><span>Long form</span></h3><p class="c1"><span>Given Graph g, Node s, Node t st child(g,s) &amp; child(g,t); Find p st path(g,s,t,p) &amp; forall(p&#39; st path(g,s,t,p&#39;) : length(p&#39;) &lt;= length(p) )</span></p><h3 class="c0" id="h.osfb5uvknpbf"><span>Short Form</span></h3><p class="c1"><span>Given graph g, nodes s,t in g, Find path p from s to t st p.length is minimized</span></p><p class="c1"><span>new syntax:</span></p><p class="c1"><span>p.length</span></p><p class="c1"><span>&quot;from s to t&quot;</span></p><p class="c1"><span>&quot;is minimized&quot;</span></p><h2 class="c0" id="h.4402vua757q"><span>Projectile motion</span></h2><p class="c1"><span>For a projectile fired at a given angle on a flat surface, calculate the time it will take it to hit the ground.</span></p><p class="c1"><span>Is this even an algorithm problem?</span></p><p class="c1"><span>Short form</span></p><p class="c1"><span>?????</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.i98ozycpien4"><span>N-Queens</span></h2><p class="c1"><span>given a chessboard of size n, find how many queens can fit without being in each others&rsquo; path3</span></p><h3 class="c0" id="h.5lqycxyxv2jf"><span>Thought Process</span></h3><p class="c1"><span>Would need ways to define a queen and how it moves, and a chessboard. Or add theorems that define them.</span></p><h3 class="c0" id="h.ng958bfkxamw"><span>Short-Form</span></h3><p class="c1"><span>Given int n, Find arrangement &#39;a&#39; of n Queens st none hit each other</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Somewhere in database : arrangement -&gt; list of points of size n</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.gvtqu2a8oir7"><span>Sum of a list (POSSIBLE)</span></h2><h3 class="c0" id="h.sy0enja2o4he"><span>Long form</span></h3><p class="c1"><span>Form 1</span></p><p class="c1"><span>Given x st type_list(x) &amp; forall(y st child(x,y) : type_int(y)), Find z st sum_elements(x,z); Theorems:</span></p><p class="c1"><span>sum_elements(x,z)-&gt; forall(y st child(x,y) : sum_elements(x-y) - y = z)</span></p><p class="c1"><span>Form 2</span></p><p class="c1"><span>Given x st type_list(x) &amp; forall(y st child(x,y) : type_int(y)), Find z st forall(y st child(x,y) : addedTo(z,y))</span></p><p class="c1 c4"><span></span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.93x3yq9v46wm"><span>Substring de</span><span>t</span><span>ection (maybe?)</span></h2><p class="c1"><span>Determine if a given string contains another given string</span></p><h3 class="c0" id="h.i4icwal7jiae"><span>Long Form</span></h3><p class="c1"><span>Given a,b st type_string(a) &amp; type_string(b), Determineif exists(i st index(a,i) : equal(substring(a,i,length(b)), b) )</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>substring(s, i, l, s2) -&gt; type_string(string) &amp; index(s,i) &amp; index(s,i)</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.y0vpckpigh43"><span>Short Form</span></h3><p class="c1"><span>Given string a,b, determine if b is a substring of a</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.1v0uo7kg8utd"><span>Count Subarray</span></h2><p class="c1"><span>Stolen from </span><span class="c6"><a class="c10" href="https://www.google.com/url?q=https://www.codechef.com/problems/SUBINC&amp;sa=D&amp;ust=1462223358346000&amp;usg=AFQjCNHiKzD09m2De2NImcfmyzsE4fzDjg">https://www.codechef.com/problems/SUBINC</a></span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Given array A, find the number of non-decreasing subarrays</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>subarray(A,i,j) is the part of A from i to j (includes i, not j)</span></p><h3 class="c0" id="h.ob98gn95gqiv"><span>Long Form</span></h3><p class="c1"><span>Still figuring out long-form, none of the things below are correct yet</span><span>.</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Given array A, Find numberof(s st subarray(A,s) st non-decreasing(s))</span></p><p class="c1"><span>lengthens to</span></p><p class="c1"><span>Given array A, Find n st n = numberof(s st subarray(A,s) &amp; non-decreasing(s))</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>subarray(A,s) -&gt; type_array(A) &amp; type_array(s) &amp; exists(int i, int j st index(A,i) &amp; index(A,j) &amp; i&lt;j : forall(k st index(s,k) : get(A,k+i) = get(s,k)))</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>non-decreasing(s) -&gt; type_series(s) &amp; forall(i,j st index(s,i) &amp; index(s,j) &amp; i &lt; j :get(s,i) &lt; get(s,j))</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.wlbmfx6pniah"><span>Short form</span></h3><p class="c1"><span>Given array A, Find numberof(s st subarray(A,s) : non-decreasing(s))</span></p><h2 class="c0" id="h.ymvd1pvukrsx"><span>Check Triangle</span></h2><p class="c1"><span>Determine if the sum of three given numbers is 180 (if three angles form a legitimate triangle)</span></p><h3 class="c0" id="h.k0i1f3nqx7rk"><span>Long Form</span></h3><p class="c1"><span>Given int a, int b, int c; Find b st b is if(a + b + c = 180)</span></p><h3 class="c0" id="h.o7bxi0p0zik9"><span>Short Form</span></h3><p class="c1"><span>Given int a, int b, int c: Determineif a + b + c = 180</span></p><h2 class="c0" id="h.82dfhw9ulzt7"><span>Palindrome</span></h2><p class="c1"><span>Determine if a given string is a palindrome</span></p><h3 class="c0" id="h.ecf8gtffsnkr"><span>Long Form</span></h3><p class="c1"><span>Given string s, exists(y : reverse(x,y) &amp; y = x)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>where</span></p><p class="c1"><span>reverse(x,ret) -&gt; type_string(x) &amp; type_string(ret) &amp; forall(i st index(x,i) : get(x,i) = get(ret,length(x)-1-i))</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.c6m0jhohuz8y"><span>Legal parentheses</span></h2><p class="c1"><span>Determine if a string contains legal parentheses, namely that if we remove every non-parentheses character, we could keep removing &quot;()&quot; and we would eventually get to the empty string</span></p><h3 class="c0" id="h.u6bzhmpten38"><span>Long Form</span></h3><p class="c1"><span>I have no idea.</span></p><h2 class="c0" id="h.zaj13mazaz1q"><span>Permutations</span></h2><p class="c1"><span>Find all permutations of a series</span></p><h3 class="c0" id="h.5ughdnmrdj4"><span>Long Form</span></h3><p class="c1"><span>Given series x, find(set s st forall(j st permutation(x,j) : child(j,s)) &amp; forall(j st child(j,s) : permutation(x,j)))</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>permutation(x,y) -&gt; type_series(x) &amp; type_series(y) &amp; forall(z st child(x,z) : child(y,z)) &amp; forall(z st child(y,z) : </span><span>child(x,z)</span><span>)</span></p><h2 class="c0" id="h.ra9fijbay6wj"><span><br>Remove duplicates from a list</span></h2><h3 class="c0" id="h.ni810ipad6e3"><span>Long Form</span></h3><p class="c1"><span>Given list x, find list y st forall(z st child(x,z) : child(y,z)) &amp; !exists(i,j st index(y,i) &amp; index(y,j) : get(y,i) = get(y,j))<br></span></p><h2 class="c0" id="h.v315jai4dafd"><span>List index equality</span></h2><p class="c1"><span>Given a list of numbers, find an index where the index equals the number (A[i] = i)</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.kl9aoust8acv"><span>Long Form</span></h3><p class="c1"><span>Given A st type_list(A) &amp; forall(x st child(A,x) : type_int(x)) ; Find i st type_int(i) &amp; index(A,i) &amp; equal(get(A,i),</span><span>i</span><span>)</span></p><h3 class="c0" id="h.n8xdhar9s63g"><span>Short Form</span></h3><p class="c1"><span>Given list&lt;int&gt; A, find int i st index(A,i) &amp; A[i]==i</span></p><h3 class="c0" id="h.hwbhjvu7riqg"><span>Thought Process</span></h3><p class="c1"><span>Given list&lt;int&gt; A, find int i st index(A,i) &amp; A[i]==i</span></p><p class="c1"><span>reduces to (by brute force)<br>Given list&lt;int&gt; A, index i st index(A,i) ; test(A[i]==i)</span></p><p class="c1"><span>reduces to (if test)</span></p><p class="c1"><span>Given list&lt;int&gt; A, index i st index(A,i) &amp; test(A[i]==i); find _ </span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.xl12so75mfx2"><span>List contains average of total list (POSSIBLE)</span></h2><p class="c1 c4"><span></span></p><p class="c1"><span>GIven a list of numbers, find a value in the list that is equal to the average of the list.</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.4r1xfgtx85d7"><span>Short form</span></h3><p class="c1 c4"><span></span></p><p class="c1"><span>Given list&lt;int&gt; A, find int x st x==sum(A)/len(A)</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.orm013hwh0p8"><span>Long form</span></h3><p class="c1 c4"><span></span></p><p class="c1"><span>Given A st type_list(A) &amp; forall(x st child(A,x):type_int(x)); Find i st type_int(i) &amp;index(A,i) &amp; equal(get(A,i),sum(A)/len(A))</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.368wbtonu47c"><span>Finding a Value in a Tree</span></h2><h3 class="c0" id="h.nnybswy8lnff"><span>Short form</span></h3><p class="c1"><span>Given tree&lt;int&gt; A, int x, find node n in A st </span><span>contains(n,x)</span></p><h3 class="c0" id="h.60985ze1kvgr"><span>Long form</span></h3><p class="c1"><span>Given A st type_tree(A) &amp; forall(x st child(A,x):type_int(x)); Find i st type_int(i) &amp; x == i</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.a7cs0yk531mh"><span>Find Subtrees</span></h2><p class="c1"><span>Given tree A and tree B, determine if tree B is a subtree of tree A</span></p><h3 class="c0" id="h.okl344upkqxr"><span>Short form</span></h3><p class="c1"><span>Given tree A, tree B, test(subtree(A,B))</span></p><h3 class="c0" id="h.7o4v4cstuhna"><span>Long Form</span></h3><p class="c1"><span>Given tree A, tree B, test(</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.ut8d3cupx2tx"><span>Finding Deepest Leaf in a Tree</span></h2><p class="c1 c4"><span></span></p><h3 class="c0" id="h.3q43fit4rgix"><span>Long Form</span></h3><p class="c1"><span>Given tree A; find node x st child(A,x) &amp; forall(node y st child(</span><span>A</span><span>,y) : dist(get_root(A),x) &gt;= dist(get_root(A),y))</span></p><h3 class="c0" id="h.flh7pnzh9fbs"><span>Short form</span></h3><p class="c1"><span>Given tree A; Find x st maximized(dist(get_root(A),x) : child(A,x))</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Given a tree A find a node x st deepest_</span><span>leaf</span><span>(A , x</span><span>)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>deepest_leaf(A,x) -&gt; type_tree(A) &amp; child(A,x) &amp; ...</span></p><p class="c1"><span>(don&#39;t need type_node(x) because child(A,x) -&gt; type_node(x))</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.uzn33ubgehlo"><span>Find largest value in a tree</span></h2><h3 class="c0" id="h.brkvo1ukeirn"><span>Short form</span></h3><p class="c1"><span>Given a tree A, find node x st child(A,x) &amp; forall(y st child(A,y) : (node x&gt;=node y))</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.tzoih5fjkht9"><span>long form</span></h3><p class="c1"><span>Given A st type_tree(A) &amp; forall(y st child(A,y):type_num(y)), find node x st child(A,x) &amp; forall (y st child(A,y) &amp; less_than_equal(y,x))</span></p><p class="c1 c4"><span class="c17"></span></p><h2 class="c0" id="h.pbr2zboo32eq"><span>Optimal Bitontic Tour (</span><span class="c6"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Bitonic_tour&amp;sa=D&amp;ust=1462223358366000&amp;usg=AFQjCNG0h7eTxeVftuOmszDzd2gWrFsqtA">https://en.wikipedia.org/wiki/Bitonic_tour</a></span><span>)</span></h2><h3 class="c0" id="h.27496j6do21e"><span>Short form</span></h3><p class="c1"><span>Given Graph G, find a new graph L st child(G) polygonal chains and sum of the edges is lowest possible and edges are not intersecting &lt;&lt;Need to improve this</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.fs74lcim4oe"><span>Determining if a Number is Prime</span></h2><p class="c1"><span>Given a number determine if it is prime or not. </span><span class="c9">(Given X, find highest Y st X%Y=0 &amp; X!=0 &amp; Y!=0. If Y!=1, then prime. Else, not prime?) (value Y should not be higher than (x)^&frac12;) (2 methods? brute force and prime number lookup of length n?)(brute force better for numbers with a low number of digits, prime number lookup better for numbers with high number of digits?)</span></p><h3 class="c0" id="h.rxc763rae6vy"><span class="c12">Short form</span></h3><p class="c1"><span>Given Int X, find Int Y st X%Y==0. </span><span class="c9">(Proves Int X is not prime)</span></p><h3 class="c0" id="h.jbuzrvr0a5jv"><span class="c12">Long Form</span></h3><p class="c1"><span>Give X st type_int(X) &amp; not_equal(X,0) &amp; not_equal(X,1); Find Y st type_int(Y) &amp; not_equal(Y,0) &amp; not_equal(Y,1) &amp; equal(X%Y, 0).</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.skt36vj02llq"><span>Though Process</span></h3><p class="c1"><span>Given Int X, find Int Y st X%Y==0</span></p><p class="c1"><span class="c9">(need help)</span></p><h3 class="c0" id="h.6ryqdfobe7b7"><span>Pseudocode (?)</span></h3><p class="c1 c4"><span></span></p><p class="c1 c4"><span></span></p><p class="c1"><span>while Y!=sqrt(X)+1</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if X%Y!=0</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if Y==sqrt(X)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return X</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y+=1</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Else</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return 0 (?)</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.fbzge8ov0kt7"><span>Finding a Sequence in an Array</span></h2><p class="c1"><span>Given an unsorted array A and an unsorted array B such that A is bigger than B, find if array B is in array A</span></p><h3 class="c0" id="h.2c538r6q38em"><span>Long form</span></h3><p class="c1"><span>Given Array&lt;int&gt; A &amp; Array&lt;int&gt; B; find int i st index(A,i) &amp; forall(int n st index(B,n) : equals(A[i+n],B[n]))</span></p><h3 class="c0" id="h.xe7t782jywy0"><span>short form</span></h3><p class="c1"><span>Given int[] A &amp; int[] B; find int i st index(A,i) &amp; forall(int n st index(B,n) : A[i+n]==B[n])</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>(should we force the user to include index(A,i+n)???)</span></p><h3 class="c0" id="h.71mq0a5za0ug"><span>Thought Process</span></h3><p class="c1"><span>can eliminate index(A,i) by brute force</span></p><p class="c1"><span>Given int[] A &amp; int[] B,int i st index(A,i); test(forall(int n st index(B,n) : A[i+n]==B[n]))</span></p><p class="c1"><span>can &quot;crack open&quot; quantifier by brute-forcing</span></p><p class="c1"><span>Given int[] A &amp; int[] B,int i st index(A,i); find int n st index(B,n) &amp; A[i+n]!=B[n]</span></p><p class="c1"><span>can be brute-forced to</span></p><p class="c1"><span>Given int[] A &amp; int[] B,int i, int n st index(B,n) &amp; index(A,i); test(A[i+n]!=B[n])</span></p><h3 class="c0" id="h.hk2q1kv7xzgl"><span>Pseudocode</span></h3><p class="c1"><span>foreach index i of A</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool works = false;</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach index n of B</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( A[i+n] != B[n] )</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;works=false;</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(works)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i</span></p><h2 class="c0" id="h.dvyjz28ycyct"><span>Searching for a value in array</span></h2><p class="c1"><span>(Yeah it&rsquo;s been stated before in a different way, but I&rsquo;m bad at programming and still figuring stuff out - Ziggy)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Given a value X and an Array A, find the index i such that A[i]==x.</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.wpzl69nyfdw6"><span>Short Form</span></h3><p class="c1"><span>Given int[] A and int X, find i st A[i]==X.</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.5s2b31jrwr56"><span>Long form</span></h3><p class="c1"><span>Given array&lt;int&gt; A and int X, find int i st index(A,i) &amp; equal(A[i],X)</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.uy2h712kmqry"><span>Find duplicate entries in array</span></h2><p class="c1"><span>Given an array A, find the indices of duplicate entries.</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.907c2no5s838"><span>Short Form</span></h3><p class="c1"><span>Given int[] A, find int i st forall( int n, A[i]==A[i+n]).</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.8cd23wzc4u9a"><span>Long From</span></h3><p class="c1"><span>Given array&lt;int&gt; A, find int i st index (A,i) &amp; forall(int n st index(A,i+n) &amp; equal(A[i],A[i+n]))</span></p><h2 class="c0" id="h.5b8p7vl5irgx"><span>Find array index which contains itself</span></h2><h3 class="c0" id="h.jngdf7cgijir"><span>Long form</span></h3><p class="c1"><span>Given array x; Find y st index(x,y) &amp; get(x,y,y)</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.7vhv239o18qw"><span>Collapse edges in graph</span></h2><p class="c1"><span>Given a euclidean graph g and an int n, remove n edges such that the sum of lengths of the remaining edges is maximized</span></p><h3 class="c0" id="h.hi674t9kj3qs"><span>Long form</span></h3><p class="c1"><span>Given euclideanGraph x, int n; Find </span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.2lcn6666zium"><span>Stable Matching</span></h2><p class="c1"><span>Find a stable matching between two equally sized sets, where:</span></p><ul class="c14 lst-kix_yy8g0k424epj-0 start"><li class="c1 c2 c7"><span>a matching is a mapping from the elements of one set to the elements of the other set</span></li><li class="c1 c7 c2"><span>each element in each set has a &#39;preference&#39; for each element in the other set</span></li><li class="c1 c7 c2"><span>there is no element A in the first set which would rather be with an element B in the second set that would also rather be with A</span></li></ul><p class="c1 c4"><span></span></p><h3 class="c0" id="h.pbm10h42vonj"><span>Short form</span></h3><p class="c1"><span>Given</span></p><p class="c1 c5"><span>set a,</span></p><p class="c1 c5"><span>set b,</span></p><p class="c1 c5"><span>map&lt;object,map&lt;object, realNumber&gt;&gt; apreferences,</span></p><p class="c1 c5"><span>map&lt;object,map&lt;object, realNumber&gt;&gt; bpreferences</span></p><p class="c1 c5"><span>st equal(size(a),size(b)) &amp;</span></p><p class="c1 c5"><span>forall(x st child(a,x) :</span></p><p class="c1 c2 c5"><span>apreferences.containsKey(x) &amp;</span></p><p class="c1 c2 c5"><span>forall(y st child(b,y) : bpreferences.get(x).containsKey(y)) &amp;</span></p><p class="c1 c5"><span>forall(x st child(b,x) :</span></p><p class="c1 c2 c5"><span>bpreferences.containsKey(x) &amp;</span></p><p class="c1 c2 c5"><span>forall(y st child(a,y) : apreferences.get(x).containsKey(y))</span></p><p class="c1"><span>;</span></p><p class="c1"><span>Find </span><span>one_to_one_mapping </span><span>m st</span></p><p class="c1 c5"><span>mapping</span><span>(a,b,m) &amp;</span></p><p class="c1 c5"><span>!exists(a1,a2,b1,b2 st</span></p><p class="c1 c2 c5"><span>mapped(m,a1,b1) &amp;</span></p><p class="c1 c2 c5"><span>mapped(m,a2,b2)</span></p><p class="c1 c2 c5"><span>:</span></p><p class="c1 c2 c5"><span>apreferences.get(a1).get(b1) &lt; apreferences.get(a1).get(b2) &amp;</span></p><p class="c1 c2 c5"><span>bpreferences.get(b1).get(a1) &lt; bpreferences.get(b1).get(a2)</span></p><p class="c1 c2"><span>) </span></p><p class="c1 c4"><span></span></p><p class="c1"><span>WHERE: </span></p><p class="c1"><span>mapping(a,b,m) &lt;-&gt; forall(x st child(a,x) : exists(y st child(b,y) : mapped(m,x,y)))</span></p><p class="c1"><span>//Dunno about this...</span></p><p class="c1"><span>one_to_one_mapping(a,b,m) &lt;-&gt; mapping(a,b,m) &amp; forall(x st child(a,x) : count(y st mapped(m,x,y)) == 1)</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.u7hyykzdrml4"><span>Train of thought (Brute Force)</span></h3><p class="c1"><span>Human version : try every possible (one to one?) mapping from a to b until we get one that meets the quantifier condition</span></p><h2 class="c0" id="h.n31jhu8mwdyz"><span>Stable Roommate Problem</span></h2><p class="c1"><span>Given a set of elements, where every element has preferences for every other, find a matching where every element of </span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.8jcac89im8za"><span>Copy of a list</span></h2><p class="c1"><span>Given a list, return a list that contains all the same elements</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.bpccl8wh4bkx"><span>Short form</span></h3><p class="c1"><span>Given list x; Find list y st forall(z st child(x,z) : child(y,z)) &amp; forall(z st !child(x,z) : !child(y,z))</span></p><p class="c1"><span>Given list x; Find list y st equal(x,y)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Solutions:</span></p><p class="c1"><span>copy list</span></p><p class="c1"><span>return given list</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.ihkzhvws6cu"><span>Sort a list by another list</span></h2><p class="c1"><span>Sort a list using the values in another list as values, namely:</span></p><p class="c1"><span>4,2,5,3,1 sorted using 9,6,7,8,5 would sort as 1 2 5 3 4</span></p><h3 class="c0" id="h.5kbpyq43at3u"><span>Short form</span></h3><p class="c1"><span>Given list tosort, list sortby, list sorted st size(tosort) = size(sortby) &amp;&amp; permutation(sortby,sorted) &amp; sorted(sorted);</span></p><p class="c1"><span>Find list newsorted st forall(i st index(sorted,i) : exists(j st </span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.d6eykp3u425s"><span>Simple Knapsack</span></h2><p class="c1"><span>Given a list of n positive doubles and an integer w, find the sublist j for whom the sum of elements in j is maximized, while being less than or equal to w</span></p><h3 class="c0" id="h.7bhvcuyzki1u"><span>Short form</span></h3><p class="c1"><span>Given list&lt;positivedouble&gt; n, int w; Find list&lt;positivedouble&gt; m st forall(x st child(m,x) : child(n,x)) &amp; sum(m) &lt;= w &amp; forall(y st forall(x st child(m,x) : child(n,x)) &amp; sum(y) &lt;= w : sum(y) &lt;= sum(m))</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Solutions:<br>Dumb:</span></p><p class="c1"><span>list best = null</span></p><p class="c1"><span>foreach sublist m of n:</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if sum(m) &lt;= w</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if best==null || sum(m) &gt; sum(best)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best = m</span></p><p class="c1"><span>continue here</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Smart:</span></p><p class="c1"><span>add in the elements smallest-first until you can&#39;t add any more</span></p><h2 class="c0" id="h.xtbqcikn948c"><span>Knapsack Problem</span></h2><p class="c1"><span>Given a list of items, each with a value and a weight, maximize the value while keeping the weight less than or equal to a certain value</span></p><h3 class="c0" id="h.jgoisqufk06f"><span>Short Form</span></h3><p class="c1"><span>Given</span></p><p class="c1 c5"><span>list&lt;positivedouble&gt; values,</span></p><p class="c1 c5"><span>list&lt;positivedouble&gt; weights,</span></p><p class="c1 c5"><span>int w</span></p><p class="c1 c5"><span>st</span></p><p class="c1 c5"><span>size(values)=size(weights)</span></p><p class="c1 c5"><span>;</span></p><p class="c1"><span>Find</span></p><p class="c1 c5"><span>list&lt;int&gt; choices</span></p><p class="c1 c5"><span>st</span></p><p class="c1 c5"><span>forall(x st child(choices,x) : index(values,x)) &amp;</span></p><p class="c1 c5"><span>sum(i = minindex(choices) to maxIndex(choices) : weights[choices[i]]) &lt;= w &amp;</span></p><p class="c1 c5"><span>forall(k st</span></p><p class="c1 c2 c5"><span>forall(x st</span></p><p class="c1 c11 c5"><span>child(k,x)</span></p><p class="c1 c11"><span>:</span></p><p class="c1 c11 c5"><span>index(values,x)</span></p><p class="c1 c11"><span>) &amp;</span></p><p class="c1 c11"><span>sum(i = minindex(k) to maxIndex(k) : weights[k[i]]) &lt;= w</span></p><p class="c1 c2"><span>:</span></p><p class="c1 c2 c5"><span>sum(i = minindex(k) to maxIndex(k) : weights[k[i]])</span></p><p class="c1 c2 c5"><span>&lt;=</span></p><p class="c1 c2 c5"><span>sum(i = minindex(choices) to maxIndex(choices) : weights[choices[i]])</span></p><p class="c1 c2"><span>)</span></p><p class="c1 c2 c4"><span></span></p><h2 class="c0" id="h.s2htuetcvld"><span>Scheduling to minimize lateness</span></h2><p class="c1"><span>Given a list of jobs with a deadline and a time each, schedule the jobs so as to minimize the highest lateness</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Given d,t st </span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.ahvbb8b9c5l5"><span>Rotating a 2d array</span></h2><p class="c1"><span>Given an NxN 2d array, write a function that returns a NxN 2d array with the input rotated 90 degrees clockwise.</span></p><p class="c1"><span>For example,</span></p><p class="c1"><span>123</span></p><p class="c1"><span>456</span></p><p class="c1"><span>789 </span></p><p class="c1"><span>would become</span></p><p class="c1"><span>741</span></p><p class="c1"><span>852</span></p><p class="c1"><span>963</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>This is an interesting example where the input is relatively simple for us to understand, but would take a lot of explaining for the program to understand.</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.8rz15r2zqhyd"><span>Adding elements to a sorted list</span></h2><p class="c1"><span>(NOTE: This section is mostly random notes on sorting)</span></p><p class="c1"><span>Given a sorted list, add an element to it in such a way as to keep it sorted</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Long form</span></p><p class="c1"><span>Given list&lt;int&gt; a, int b st mutable(a) &amp; sorted(a); Find c st </span><span>copy(a,c) &amp; child(c,b)</span><span>&nbsp;&amp; sorted(c)</span></p><p class="c1"><span>or?</span></p><p class="c1"><span>Given list&lt;int&gt; a, int b st mutable(a) &amp; sorted(a); Find c st add(a,b,c) &amp; sorted(c)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Should eventually reduce to</span></p><p class="c1"><span>Given list&lt;int&gt; a, int b, c st mutable(a) &amp; sorted(a) &amp; sort_of_clone(a,c);</span></p><p class="c1"><span>Find i st add(a,b,c,i) &amp; sorted(c)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>sorted(x) -&gt; forall(i,j st index(x,i) &amp; index(x,j) &amp; lessThan(i,j) : lessThan(get(x,i), get(x,j)))</span></p><p class="c1"><span>sorted(x) -&gt; forall(i st index(x,i) &amp; i &gt; 0 : get(x,i) &gt; get(x,i-1))</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;-&gt; forall(i,xi,xj st index(x,i) &amp; i &gt; 0 &amp; get(x,i,xi) &amp; get(x,i-1,xj) : greaterThanEqual(xi,xj))</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>//These are some rules related to lists that we&#39;d need for this to work...</span></p><p class="c1"><span>get(x,i,xi) -&gt; index(x,i) &amp; child(x,xi)</span></p><p class="c1"><span>child(a,b) -&gt; exists(i st index(a,i) &amp; get(a,i,b)) // do we need this?</span></p><p class="c1"><span>add(original,element,new) -&gt; exists(i st </span><span>add</span><span>(original,element,new,i))</span></p><p class="c1"><span>add</span><span>(original,element,new,add_index) -&gt; // Or something similar.</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in_range(add_index,0,size(original))</span><span>&nbsp;&amp;</span></p><p class="c1 c5"><span>forall(i st in_range(i,0,add_index) : equal(get(original,i),get(new,i)) &amp;</span></p><p class="c1 c5"><span>forall(i st in_range(i,add_index,size(original)) : equal(get(original,i),get(new,i+1)) &amp;</span></p><p class="c1 c5"><span>get(new,add_index,element)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>can_add(original,element,new) &lt;-&gt; exists(i st can_add(original,element,new,i))</span></p><p class="c1"><span>can_add(original,element,new,add_index) -&gt; in_range(add_index,0,size(original))</span></p><p class="c1 c4"><span></span></p><p class="c1 c4"><span></span></p><p class="c1"><span>forall(x st child(original,x) : child(new,x)) &amp; child(new,element) &amp; </span></p><p class="c1 c4"><span></span></p><p class="c1"><span>copy(a,c) -&gt; ??????</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Thought process:<br>We want to solve child(c,b) &amp; sorted(c) on &quot;c&quot; that is somehow known to actually be a</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>The most terrible solution that&#39;s still correct is:<br>for each index i of a</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = copy of a</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.insert(i,b)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if d is sor</span><span>t</span><span>ed</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>This would make the full sorting algorithm be:</span></p><p class="c1"><span>Given list a; Find b st permutation(a,b) &amp; sorted(b)</span></p><p class="c1"><span>for each element d in a</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for each index i in b</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = copy of b</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.insert(d,i)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if c is sorted</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.insert(d,i)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Runtime : O(n^3)</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.uvge8k39o8de"><span>Determine if two objects are NOT in a list</span></h2><p class="c1"><span>Given a list &#39;a&#39; and two objects &#39;b&#39; and &#39;c&#39;, determine if they&#39;re both not in the list (this problem is only interesting because of how the program fails it)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Given list a,b,c; Find !child(a,b) &amp; !child(a,c)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Current solution (NOTE: This is wrong):</span></p><p class="c1"><span>boolean v0 = true;</span></p><p class="c1"><span>foreach child na of a</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b == na</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0 = false</span></p><p class="c1"><span>if v0 == true</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b == c</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return []</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>This solution is basically : &quot;Find if b is not in the list. If c is the same as b, then we&#39;re done!&quot;. While this will technically work in some cases, it&#39;s clearly not a general solution.</span></p><h2 class="c0" id="h.ea258ox0faj2"><span>Subset Sum</span></h2><p class="c1"><span>Given items with weights w1...wn and capacity W, find set S of items st the sum over i in s of wi &lt;= W and maximize sum over i in s of w</span></p><h2 class="c0" id="h.enty9248lob9"><span>Cycle in a graph</span></h2><p class="c1"><span>Given a graph g, determine if g contains a cycle</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Given undirected_graph g; Find exists(path p st cycle(p) &amp; contains(g,p))</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Thought process</span></p><p class="c1"><span>(Stupid solution)</span></p><p class="c1"><span>The dumb solution for finding a cycle is to try every possible combination of nodes until we find one that&#39;s a path and a cycle</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>contains(g,p) &lt;-&gt; forall(v st child(p,v) : child(g,v))</span></p><p class="c1 c4"><span></span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Good solution:</span></p><p class="c1"><span>na = new HashSet()<br>for each vertex v in g by BFS from some node</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(na.contains(v))</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;na.add(v)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Thoughts on getting there:</span></p><p class="c1"><span>must realize that the accumulation in the bfs leads to a cycle?</span></p><h2 class="c0" id="h.q33rq3lx3okt"><span>List of Multiples of 3 and 5</span></h2><p class="c1"><span class="c3 c16">Find the list of all the multiples of 3 or 5 below 1000.</span></p><h3 class="c0" id="h.o4e2n9o9fli3"><span>Short form</span></h3><p class="c1"><span>Given ; Find list x st forall(int n : 0 &lt; n &lt;= 1000 &amp; (n % 3 == 0 | n % 5 == 0) -&gt; child(x,n))</span></p><h3 class="c0" id="h.5bdmbkgv9nbi"><span>Long form</span></h3><p class="c1"><span class="c3">Given ; Find list x st forall( int n : inRange(n,0,1000) &amp; (mod(n,3,0) | mod(n,5,0)) -&gt; child(x,n))</span></p><h3 class="c0" id="h.kakxlczabvxf"><span>Desired Pseudocode</span></h3><p class="c1"><span>List x;</span></p><p class="c1"><span>for(int i=0;i&lt;1000;i++)</span></p><p class="c1 c5"><span>if(i%3==0 || i%5==0)</span></p><p class="c1 c2 c5"><span>x.push(i);</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Return x;</span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.jrnqakl9ki36"><span>Steps</span></h3><p class="c1"><span class="c3">Given ; Find list x st forall( int n : inRange(n,0,1000) &amp; (mod(n,3,0) | mod(n,5,0)) -&gt; child(x,n))</span></p><p class="c1"><span class="c3">Given ; Find list x st forall( int n : !lessThanEqual(0,n) | !greaterThanEqual(1000,n) | (!mod(n,3,0) &amp; !mod(n,5,0)) | child(x,n))</span></p><p class="c1 c4"><span class="c3"></span></p><p class="c1"><span class="c3">Step 1:</span></p><p class="c1"><span class="c3">Remove quantifier </span></p><p class="c1"><span class="c3">Reduces to a subproblem</span></p><p class="c1"><span class="c3">Given list x; Find int n : lessThanEqual(0,n) &amp; greaterThanEqual(1000,n) &amp; (mod(n,3,0) | mod(n,5,0)) &amp; !child(x,n)</span></p><p class="c1"><span class="c3">For a universal quantifier, try every possible value and if you find an exception, then the quantifier is false</span></p><p class="c1 c4"><span class="c3"></span></p><p class="c1"><span class="c3">[</span></p><p class="c1"><span class="c3">Can eliminate &quot;lessThanEqual(0,n) &amp; greaterThanEqual(1000,n)&quot;</span></p><p class="c1"><span class="c3">Turns our source code to &quot;</span><span>for(int n=0;n&lt;1000;n++)&quot;</span></p><p class="c1"><span class="c3">Given list x, int n; Find : (mod(n,3,0) | mod(n,5,0)) &amp; !child(x,n)</span></p><p class="c1"><span class="c3">]</span></p><p class="c1"><span class="c3">[</span></p><p class="c1"><span class="c3">Can eliminate &quot;(mod(n,3,0) | mod(n,5,0))&quot;</span></p><p class="c1"><span class="c3">Adds &quot;</span><span>if(i%3==0 || i%5==0)&quot;</span></p><p class="c1"><span class="c3">Given list x, int n; Find : !child(x,n)</span></p><p class="c1"><span class="c3">]</span></p><p class="c1 c4"><span class="c3"></span></p><p class="c1"><span class="c3">List of used atomics and their definitions:</span></p><p class="c1"><span class="c3">inRange(n,s,e) &lt;-&gt; </span><span class="c3">lessThanEqual</span><span class="c3">(s,n) &amp; greaterThanEqual(e,n)</span></p><p class="c1"><span class="c3">mod(n,a,b) &lt;-&gt; remainder(n,a,b)</span></p><p class="c1 c4"><span class="c3"></span></p><p class="c1"><span class="c3">List of Meta-algorithms and their definitions:</span></p><p class="c1"><span class="c3">If we have a constraint that a number must be &lt;= something and &gt;= something, then we can just try all possible values in that range</span></p><p class="c1"><span class="c3">Problems:</span></p><ul class="c14 lst-kix_kh96yhlvmyzg-0 start"><li class="c1 c7 c2"><span class="c3">Range might be illegal</span></li><li class="c1 c7 c2"><span class="c3">They might use &gt;,&lt; instead of &lt;= (define the range differently)</span></li></ul><p class="c1 c4"><span class="c3"></span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Deliverables:<br>Added the &lt;, &lt;=, %, == sugars (etc)</span></p><p class="c1"><span>Added the inrange atomic</span></p><p class="c1"><span>Defined the inrange atomic</span></p><p class="c1"><span>Define the mod atomic</span></p><p class="c1 c4"><span></span></p><p class="c1"><span class="c15">Smallest Multiple</span></p><p class="c1"><span class="c6"><a class="c10" href="https://www.google.com/url?q=https://projecteuler.net/problem%3D5&amp;sa=D&amp;ust=1462223358423000&amp;usg=AFQjCNGXDGLhVPlaBbsQrul6MnL9eL7gYw">https://projecteuler.net/problem=5</a></span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Short Form</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Given; Find k st forall(i : </span><span>1</span><span>&lt;=i&lt;=20 -&gt; k%i==0) &amp; forall(j st forall(i : 1&lt;=i&lt;=20 -&gt; j%i==0) -&gt; k&lt;=j)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Long Form</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Given; Find k st forall(i : inRange(i,1,20) -&gt; mod(k,i,0)) &amp; forall(j st forall(i : 1&lt;=i&lt;=20 -&gt; j%i==0) -&gt; k&lt;=j)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Desired Pseudocode</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Int k;</span></p><p class="c1"><span>while(true){</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bool works = true;</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i =1;i&lt;20;i++){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(k%i != 0)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Works = false;</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(works)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return k</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k++;</span></p><p class="c1"><span>}</span></p><p class="c1 c4"><span></span></p><p class="c1 c4"><span></span></p><p class="c1"><span>New Atomics:</span></p><p class="c1"><span>inRange(i,a,b) &lt;-&gt; lessthanequals(i,b) &amp; greaterthanequals(i,a)</span></p><p class="c1 c4"><span></span></p><h2 class="c0" id="h.lqtbzcmpyfhp"><span>Copying list</span></h2><p class="c1"><span>Given a list, copy the list</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>Given list x; Find list y st forall(z st child(x,z) -&gt; child(y,z))</span></p><p class="c1 c4"><span></span></p><p class="c1 c4"><span></span></p><p class="c1 c4"><span></span></p><h3 class="c0" id="h.jkktfvdhjplq"><span>Process</span></h3><p class="c1 c4"><span></span></p><p class="c1"><span>Given list x; Find list y st forall(z st child(x,z) -&gt; child(y,z))</span></p><p class="c1"><span>Given list x, list yp; Find list y st proxy(y,yp) &amp; forall(z st !child(x,z) | child(y,z))</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given list x, list yp; Find z st child(x,z)</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given list x, list yp, z st !child(x,z); Find y st child(y,z)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>yp = new list()</span></p><p class="c1"><span>For each child z of x</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yp.add(z)</span></p><p class="c1 c4"><span></span></p><p class="c1"><span>y = yp</span></p>
							</div>
						</section>
					</article>

				<!-- Footer -->
					<footer id="footer">
						<ul class="icons">
							<li><a href="#" class="icon fa-envelope-o"><span class="label">Email</span></a></li>
						</ul>
						<ul class="copyright">
							<li>&copy; MOAP Inc.</li>
						</ul>
					</footer>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="assets/js/main.js"></script>

	</body>
</html>
