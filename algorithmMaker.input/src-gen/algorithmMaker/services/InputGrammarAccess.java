/*
 * generated by Xtext
 */
package algorithmMaker.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class InputGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class InputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Input");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGivenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cGivenAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cGivenAlternatives_1_0 = (Alternatives)cGivenAssignment_1.eContents().get(0);
		private final RuleCall cGivenProblemPropertyOptionalParserRuleCall_1_0_0 = (RuleCall)cGivenAlternatives_1_0.eContents().get(0);
		private final RuleCall cGivenProblemNoVarsParserRuleCall_1_0_1 = (RuleCall)cGivenAlternatives_1_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cTaskAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final Alternatives cTaskAlternatives_3_0_0 = (Alternatives)cTaskAssignment_3_0.eContents().get(0);
		private final Keyword cTaskFindKeyword_3_0_0_0 = (Keyword)cTaskAlternatives_3_0_0.eContents().get(0);
		private final Keyword cTaskCountKeyword_3_0_0_1 = (Keyword)cTaskAlternatives_3_0_0.eContents().get(1);
		private final Assignment cGoalAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final Alternatives cGoalAlternatives_3_1_0 = (Alternatives)cGoalAssignment_3_1.eContents().get(0);
		private final RuleCall cGoalProblemParserRuleCall_3_1_0_0 = (RuleCall)cGoalAlternatives_3_1_0.eContents().get(0);
		private final RuleCall cGoalProblemNoVarsParserRuleCall_3_1_0_1 = (RuleCall)cGoalAlternatives_3_1_0.eContents().get(1);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Keyword cTheoremsKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cTheoremsAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cTheoremsTheoremParserRuleCall_4_2_0 = (RuleCall)cTheoremsAssignment_4_2.eContents().get(0);
		private final Group cGroup_4_3 = (Group)cGroup_4.eContents().get(3);
		private final Keyword cSemicolonKeyword_4_3_0 = (Keyword)cGroup_4_3.eContents().get(0);
		private final Assignment cTheoremsAssignment_4_3_1 = (Assignment)cGroup_4_3.eContents().get(1);
		private final RuleCall cTheoremsTheoremParserRuleCall_4_3_1_0 = (RuleCall)cTheoremsAssignment_4_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_4 = (Keyword)cGroup_4.eContents().get(4);
		
		////NOTE: Any changes to the formatting should be reflected with changes here.
		//Input:
		//	"Given" given=(ProblemPropertyOptional | ProblemNoVars) ";" (task=("Find" | "Count") goal=(Problem | ProblemNoVars))?
		//	(";" "Theorems:" theorems+=Theorem (";" theorems+=Theorem)* ";"?)?;
		@Override public ParserRule getRule() { return rule; }

		//"Given" given=(ProblemPropertyOptional | ProblemNoVars) ";" (task=("Find" | "Count") goal=(Problem | ProblemNoVars))?
		//(";" "Theorems:" theorems+=Theorem (";" theorems+=Theorem)* ";"?)?
		public Group getGroup() { return cGroup; }

		//"Given"
		public Keyword getGivenKeyword_0() { return cGivenKeyword_0; }

		//given=(ProblemPropertyOptional | ProblemNoVars)
		public Assignment getGivenAssignment_1() { return cGivenAssignment_1; }

		//ProblemPropertyOptional | ProblemNoVars
		public Alternatives getGivenAlternatives_1_0() { return cGivenAlternatives_1_0; }

		//ProblemPropertyOptional
		public RuleCall getGivenProblemPropertyOptionalParserRuleCall_1_0_0() { return cGivenProblemPropertyOptionalParserRuleCall_1_0_0; }

		//ProblemNoVars
		public RuleCall getGivenProblemNoVarsParserRuleCall_1_0_1() { return cGivenProblemNoVarsParserRuleCall_1_0_1; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }

		//(task=("Find" | "Count") goal=(Problem | ProblemNoVars))?
		public Group getGroup_3() { return cGroup_3; }

		//task=("Find" | "Count")
		public Assignment getTaskAssignment_3_0() { return cTaskAssignment_3_0; }

		//"Find" | "Count"
		public Alternatives getTaskAlternatives_3_0_0() { return cTaskAlternatives_3_0_0; }

		//"Find"
		public Keyword getTaskFindKeyword_3_0_0_0() { return cTaskFindKeyword_3_0_0_0; }

		//"Count"
		public Keyword getTaskCountKeyword_3_0_0_1() { return cTaskCountKeyword_3_0_0_1; }

		//goal=(Problem | ProblemNoVars)
		public Assignment getGoalAssignment_3_1() { return cGoalAssignment_3_1; }

		//Problem | ProblemNoVars
		public Alternatives getGoalAlternatives_3_1_0() { return cGoalAlternatives_3_1_0; }

		//Problem
		public RuleCall getGoalProblemParserRuleCall_3_1_0_0() { return cGoalProblemParserRuleCall_3_1_0_0; }

		//ProblemNoVars
		public RuleCall getGoalProblemNoVarsParserRuleCall_3_1_0_1() { return cGoalProblemNoVarsParserRuleCall_3_1_0_1; }

		//(";" "Theorems:" theorems+=Theorem (";" theorems+=Theorem)* ";"?)?
		public Group getGroup_4() { return cGroup_4; }

		//";"
		public Keyword getSemicolonKeyword_4_0() { return cSemicolonKeyword_4_0; }

		//"Theorems:"
		public Keyword getTheoremsKeyword_4_1() { return cTheoremsKeyword_4_1; }

		//theorems+=Theorem
		public Assignment getTheoremsAssignment_4_2() { return cTheoremsAssignment_4_2; }

		//Theorem
		public RuleCall getTheoremsTheoremParserRuleCall_4_2_0() { return cTheoremsTheoremParserRuleCall_4_2_0; }

		//(";" theorems+=Theorem)*
		public Group getGroup_4_3() { return cGroup_4_3; }

		//";"
		public Keyword getSemicolonKeyword_4_3_0() { return cSemicolonKeyword_4_3_0; }

		//theorems+=Theorem
		public Assignment getTheoremsAssignment_4_3_1() { return cTheoremsAssignment_4_3_1; }

		//Theorem
		public RuleCall getTheoremsTheoremParserRuleCall_4_3_1_0() { return cTheoremsTheoremParserRuleCall_4_3_1_0; }

		//";"?
		public Keyword getSemicolonKeyword_4_4() { return cSemicolonKeyword_4_4; }
	}

	public class ProblemNoVarsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProblemNoVars");
		private final Assignment cPropertyAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPropertyImplicationParserRuleCall_0 = (RuleCall)cPropertyAssignment.eContents().get(0);
		
		//ProblemNoVars returns Problem:
		//	property=Implication;
		@Override public ParserRule getRule() { return rule; }

		//property=Implication
		public Assignment getPropertyAssignment() { return cPropertyAssignment; }

		//Implication
		public RuleCall getPropertyImplicationParserRuleCall_0() { return cPropertyImplicationParserRuleCall_0; }
	}

	public class ProblemPropertyOptionalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProblemPropertyOptional");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarsDeclarationParserRuleCall_0_0 = (RuleCall)cVarsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVarsDeclarationParserRuleCall_1_1_0 = (RuleCall)cVarsAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cStKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cPropertyAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPropertyImplicationParserRuleCall_2_1_0 = (RuleCall)cPropertyAssignment_2_1.eContents().get(0);
		
		//ProblemPropertyOptional returns Problem:
		//	vars+=Declaration ("," vars+=Declaration)* ("st" property=Implication)?;
		@Override public ParserRule getRule() { return rule; }

		//vars+=Declaration ("," vars+=Declaration)* ("st" property=Implication)?
		public Group getGroup() { return cGroup; }

		//vars+=Declaration
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }

		//Declaration
		public RuleCall getVarsDeclarationParserRuleCall_0_0() { return cVarsDeclarationParserRuleCall_0_0; }

		//("," vars+=Declaration)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//vars+=Declaration
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }

		//Declaration
		public RuleCall getVarsDeclarationParserRuleCall_1_1_0() { return cVarsDeclarationParserRuleCall_1_1_0; }

		//("st" property=Implication)?
		public Group getGroup_2() { return cGroup_2; }

		//"st"
		public Keyword getStKeyword_2_0() { return cStKeyword_2_0; }

		//property=Implication
		public Assignment getPropertyAssignment_2_1() { return cPropertyAssignment_2_1; }

		//Implication
		public RuleCall getPropertyImplicationParserRuleCall_2_1_0() { return cPropertyImplicationParserRuleCall_2_1_0; }
	}

	public class ProblemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Problem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarsDeclarationParserRuleCall_0_0 = (RuleCall)cVarsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVarsDeclarationParserRuleCall_1_1_0 = (RuleCall)cVarsAssignment_1_1.eContents().get(0);
		private final Keyword cStKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPropertyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPropertyImplicationParserRuleCall_3_0 = (RuleCall)cPropertyAssignment_3.eContents().get(0);
		
		//Problem:
		//	vars+=Declaration ("," vars+=Declaration)* "st" property=Implication;
		@Override public ParserRule getRule() { return rule; }

		//vars+=Declaration ("," vars+=Declaration)* "st" property=Implication
		public Group getGroup() { return cGroup; }

		//vars+=Declaration
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }

		//Declaration
		public RuleCall getVarsDeclarationParserRuleCall_0_0() { return cVarsDeclarationParserRuleCall_0_0; }

		//("," vars+=Declaration)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//vars+=Declaration
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }

		//Declaration
		public RuleCall getVarsDeclarationParserRuleCall_1_1_0() { return cVarsDeclarationParserRuleCall_1_1_0; }

		//"st"
		public Keyword getStKeyword_2() { return cStKeyword_2; }

		//property=Implication
		public Assignment getPropertyAssignment_3() { return cPropertyAssignment_3; }

		//Implication
		public RuleCall getPropertyImplicationParserRuleCall_3_0() { return cPropertyImplicationParserRuleCall_3_0; }
	}

	public class ProblemColonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProblemColon");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarsDeclarationParserRuleCall_0_0 = (RuleCall)cVarsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVarsDeclarationParserRuleCall_1_1_0 = (RuleCall)cVarsAssignment_1_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPropertyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPropertyImplicationParserRuleCall_3_0 = (RuleCall)cPropertyAssignment_3.eContents().get(0);
		
		//ProblemColon returns Problem:
		//	vars+=Declaration ("," vars+=Declaration)* ":" property=Implication;
		@Override public ParserRule getRule() { return rule; }

		//vars+=Declaration ("," vars+=Declaration)* ":" property=Implication
		public Group getGroup() { return cGroup; }

		//vars+=Declaration
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }

		//Declaration
		public RuleCall getVarsDeclarationParserRuleCall_0_0() { return cVarsDeclarationParserRuleCall_0_0; }

		//("," vars+=Declaration)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//vars+=Declaration
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }

		//Declaration
		public RuleCall getVarsDeclarationParserRuleCall_1_1_0() { return cVarsDeclarationParserRuleCall_1_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//property=Implication
		public Assignment getPropertyAssignment_3() { return cPropertyAssignment_3; }

		//Implication
		public RuleCall getPropertyImplicationParserRuleCall_3_0() { return cPropertyImplicationParserRuleCall_3_0; }
	}

	public class DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cVarNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarNameIDTerminalRuleCall_1_0 = (RuleCall)cVarNameAssignment_1.eContents().get(0);
		
		//Declaration:
		//	type=Type? varName=ID;
		@Override public ParserRule getRule() { return rule; }

		//type=Type? varName=ID
		public Group getGroup() { return cGroup; }

		//type=Type?
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_0_0() { return cTypeTypeParserRuleCall_0_0; }

		//varName=ID
		public Assignment getVarNameAssignment_1() { return cVarNameAssignment_1; }

		//ID
		public RuleCall getVarNameIDTerminalRuleCall_1_0() { return cVarNameIDTerminalRuleCall_1_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTemplateTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTemplateTypeTypeParserRuleCall_1_1_0 = (RuleCall)cTemplateTypeAssignment_1_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//Type:
		//	name=ID ("<" templateType=Type ">")?;
		@Override public ParserRule getRule() { return rule; }

		//name=ID ("<" templateType=Type ">")?
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//("<" templateType=Type ">")?
		public Group getGroup_1() { return cGroup_1; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0() { return cLessThanSignKeyword_1_0; }

		//templateType=Type
		public Assignment getTemplateTypeAssignment_1_1() { return cTemplateTypeAssignment_1_1; }

		//Type
		public RuleCall getTemplateTypeTypeParserRuleCall_1_1_0() { return cTemplateTypeTypeParserRuleCall_1_1_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_2() { return cGreaterThanSignKeyword_1_2; }
	}

	public class ImplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Implication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cORingParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImplicationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cImplicationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cImplicationAlternatives_1_1_0 = (Alternatives)cImplicationAssignment_1_1.eContents().get(0);
		private final Keyword cImplicationHyphenMinusGreaterThanSignKeyword_1_1_0_0 = (Keyword)cImplicationAlternatives_1_1_0.eContents().get(0);
		private final Keyword cImplicationLessThanSignHyphenMinusKeyword_1_1_0_1 = (Keyword)cImplicationAlternatives_1_1_0.eContents().get(1);
		private final Keyword cImplicationLessThanSignHyphenMinusGreaterThanSignKeyword_1_1_0_2 = (Keyword)cImplicationAlternatives_1_1_0.eContents().get(2);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightORingParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Implication returns Property:
		//	ORing ({Implication.left=current} implication=("->" | "<-" | "<->") right=ORing)?;
		@Override public ParserRule getRule() { return rule; }

		//ORing ({Implication.left=current} implication=("->" | "<-" | "<->") right=ORing)?
		public Group getGroup() { return cGroup; }

		//ORing
		public RuleCall getORingParserRuleCall_0() { return cORingParserRuleCall_0; }

		//({Implication.left=current} implication=("->" | "<-" | "<->") right=ORing)?
		public Group getGroup_1() { return cGroup_1; }

		//{Implication.left=current}
		public Action getImplicationLeftAction_1_0() { return cImplicationLeftAction_1_0; }

		//implication=("->" | "<-" | "<->")
		public Assignment getImplicationAssignment_1_1() { return cImplicationAssignment_1_1; }

		//"->" | "<-" | "<->"
		public Alternatives getImplicationAlternatives_1_1_0() { return cImplicationAlternatives_1_1_0; }

		//"->"
		public Keyword getImplicationHyphenMinusGreaterThanSignKeyword_1_1_0_0() { return cImplicationHyphenMinusGreaterThanSignKeyword_1_1_0_0; }

		//"<-"
		public Keyword getImplicationLessThanSignHyphenMinusKeyword_1_1_0_1() { return cImplicationLessThanSignHyphenMinusKeyword_1_1_0_1; }

		//"<->"
		public Keyword getImplicationLessThanSignHyphenMinusGreaterThanSignKeyword_1_1_0_2() { return cImplicationLessThanSignHyphenMinusGreaterThanSignKeyword_1_1_0_2; }

		//right=ORing
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ORing
		public RuleCall getRightORingParserRuleCall_1_2_0() { return cRightORingParserRuleCall_1_2_0; }
	}

	public class ORingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ORing");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cANDingParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cORingLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightANDingParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ORing returns Property:
		//	ANDing ({ORing.left=current} "|" right=ANDing)*;
		@Override public ParserRule getRule() { return rule; }

		//ANDing ({ORing.left=current} "|" right=ANDing)*
		public Group getGroup() { return cGroup; }

		//ANDing
		public RuleCall getANDingParserRuleCall_0() { return cANDingParserRuleCall_0; }

		//({ORing.left=current} "|" right=ANDing)*
		public Group getGroup_1() { return cGroup_1; }

		//{ORing.left=current}
		public Action getORingLeftAction_1_0() { return cORingLeftAction_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_1_1() { return cVerticalLineKeyword_1_1; }

		//right=ANDing
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ANDing
		public RuleCall getRightANDingParserRuleCall_1_2_0() { return cRightANDingParserRuleCall_1_2_0; }
	}

	public class ANDingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ANDing");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cANDingLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ANDing returns Property:
		//	Primary ({ANDing.left=current} "&" right=Primary)*;
		@Override public ParserRule getRule() { return rule; }

		//Primary ({ANDing.left=current} "&" right=Primary)*
		public Group getGroup() { return cGroup; }

		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }

		//({ANDing.left=current} "&" right=Primary)*
		public Group getGroup_1() { return cGroup_1; }

		//{ANDing.left=current}
		public Action getANDingLeftAction_1_0() { return cANDingLeftAction_1_0; }

		//"&"
		public Keyword getAmpersandKeyword_1_1() { return cAmpersandKeyword_1_1; }

		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}

	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomicParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQuantifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cGroupingParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBooleanLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cNegationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Primary returns Property:
		//	Atomic | Quantifier | Grouping | BooleanLiteral | Negation;
		@Override public ParserRule getRule() { return rule; }

		//Atomic | Quantifier | Grouping | BooleanLiteral | Negation
		public Alternatives getAlternatives() { return cAlternatives; }

		//Atomic
		public RuleCall getAtomicParserRuleCall_0() { return cAtomicParserRuleCall_0; }

		//Quantifier
		public RuleCall getQuantifierParserRuleCall_1() { return cQuantifierParserRuleCall_1; }

		//Grouping
		public RuleCall getGroupingParserRuleCall_2() { return cGroupingParserRuleCall_2; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_3() { return cBooleanLiteralParserRuleCall_3; }

		//Negation
		public RuleCall getNegationParserRuleCall_4() { return cNegationParserRuleCall_4; }
	}

	public class GroupingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Grouping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cImplicationParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Grouping returns Property:
		//	"(" Implication ")";
		@Override public ParserRule getRule() { return rule; }

		//"(" Implication ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//Implication
		public RuleCall getImplicationParserRuleCall_1() { return cImplicationParserRuleCall_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class NegationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Negation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNegatedAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNegatedPrimaryParserRuleCall_1_0 = (RuleCall)cNegatedAssignment_1.eContents().get(0);
		
		//Negation:
		//	"!" negated=Primary;
		@Override public ParserRule getRule() { return rule; }

		//"!" negated=Primary
		public Group getGroup() { return cGroup; }

		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//negated=Primary
		public Assignment getNegatedAssignment_1() { return cNegatedAssignment_1; }

		//Primary
		public RuleCall getNegatedPrimaryParserRuleCall_1_0() { return cNegatedPrimaryParserRuleCall_1_0; }
	}

	public class QuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Quantifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQuantifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cQuantifierAlternatives_0_0 = (Alternatives)cQuantifierAssignment_0.eContents().get(0);
		private final Keyword cQuantifierForallKeyword_0_0_0 = (Keyword)cQuantifierAlternatives_0_0.eContents().get(0);
		private final Keyword cQuantifierExistsKeyword_0_0_1 = (Keyword)cQuantifierAlternatives_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSubjectAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSubjectProblemColonParserRuleCall_2_0 = (RuleCall)cSubjectAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Quantifier:
		//	quantifier=("forall" | "exists") "(" subject=ProblemColon ")";
		@Override public ParserRule getRule() { return rule; }

		//quantifier=("forall" | "exists") "(" subject=ProblemColon ")"
		public Group getGroup() { return cGroup; }

		//quantifier=("forall" | "exists")
		public Assignment getQuantifierAssignment_0() { return cQuantifierAssignment_0; }

		//"forall" | "exists"
		public Alternatives getQuantifierAlternatives_0_0() { return cQuantifierAlternatives_0_0; }

		//"forall"
		public Keyword getQuantifierForallKeyword_0_0_0() { return cQuantifierForallKeyword_0_0_0; }

		//"exists"
		public Keyword getQuantifierExistsKeyword_0_0_1() { return cQuantifierExistsKeyword_0_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//subject=ProblemColon
		public Assignment getSubjectAssignment_2() { return cSubjectAssignment_2; }

		//ProblemColon
		public RuleCall getSubjectProblemColonParserRuleCall_2_0() { return cSubjectProblemColonParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class AtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atomic");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFunctionIDTerminalRuleCall_0_0 = (RuleCall)cFunctionAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cArgsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cArgsAdditionParserRuleCall_2_0_0 = (RuleCall)cArgsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cArgsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cArgsAdditionParserRuleCall_2_1_1_0 = (RuleCall)cArgsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Atomic:
		//	Function=ID "(" (args+=Addition ("," args+=Addition)*)? ")";
		@Override public ParserRule getRule() { return rule; }

		//Function=ID "(" (args+=Addition ("," args+=Addition)*)? ")"
		public Group getGroup() { return cGroup; }

		//Function=ID
		public Assignment getFunctionAssignment_0() { return cFunctionAssignment_0; }

		//ID
		public RuleCall getFunctionIDTerminalRuleCall_0_0() { return cFunctionIDTerminalRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(args+=Addition ("," args+=Addition)*)?
		public Group getGroup_2() { return cGroup_2; }

		//args+=Addition
		public Assignment getArgsAssignment_2_0() { return cArgsAssignment_2_0; }

		//Addition
		public RuleCall getArgsAdditionParserRuleCall_2_0_0() { return cArgsAdditionParserRuleCall_2_0_0; }

		//("," args+=Addition)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//args+=Addition
		public Assignment getArgsAssignment_2_1_1() { return cArgsAssignment_2_1_1; }

		//Addition
		public RuleCall getArgsAdditionParserRuleCall_2_1_1_0() { return cArgsAdditionParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cValueAlternatives_0 = (Alternatives)cValueAssignment.eContents().get(0);
		private final Keyword cValueTRUEKeyword_0_0 = (Keyword)cValueAlternatives_0.eContents().get(0);
		private final Keyword cValueFALSEKeyword_0_1 = (Keyword)cValueAlternatives_0.eContents().get(1);
		
		//BooleanLiteral:
		//	value=("TRUE" | "FALSE");
		@Override public ParserRule getRule() { return rule; }

		//value=("TRUE" | "FALSE")
		public Assignment getValueAssignment() { return cValueAssignment; }

		//"TRUE" | "FALSE"
		public Alternatives getValueAlternatives_0() { return cValueAlternatives_0; }

		//"TRUE"
		public Keyword getValueTRUEKeyword_0_0() { return cValueTRUEKeyword_0_0; }

		//"FALSE"
		public Keyword getValueFALSEKeyword_0_1() { return cValueFALSEKeyword_0_1; }
	}

	public class TheoremElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Theorem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cContentAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cContentImplicationParserRuleCall_0_0 = (RuleCall)cContentAssignment_0.eContents().get(0);
		private final Keyword cColonColonColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		
		//Theorem:
		//	content=Implication ":::" Description=STRING;
		@Override public ParserRule getRule() { return rule; }

		//content=Implication ":::" Description=STRING
		public Group getGroup() { return cGroup; }

		//content=Implication
		public Assignment getContentAssignment_0() { return cContentAssignment_0; }

		//Implication
		public RuleCall getContentImplicationParserRuleCall_0_0() { return cContentImplicationParserRuleCall_0_0; }

		//":::"
		public Keyword getColonColonColonKeyword_1() { return cColonColonColonKeyword_1; }

		//Description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }

		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cSymbolAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cSymbolAlternatives_1_1_0 = (Alternatives)cSymbolAssignment_1_1.eContents().get(0);
		private final Keyword cSymbolPlusSignKeyword_1_1_0_0 = (Keyword)cSymbolAlternatives_1_1_0.eContents().get(0);
		private final Keyword cSymbolHyphenMinusKeyword_1_1_0_1 = (Keyword)cSymbolAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// **********Math things**********
		//Addition returns NumericalProperty:
		//	Multiplication ({Addition.left=current} symbol=("+" | "-") right=Multiplication)*;
		@Override public ParserRule getRule() { return rule; }

		//Multiplication ({Addition.left=current} symbol=("+" | "-") right=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//({Addition.left=current} symbol=("+" | "-") right=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{Addition.left=current}
		public Action getAdditionLeftAction_1_0() { return cAdditionLeftAction_1_0; }

		//symbol=("+" | "-")
		public Assignment getSymbolAssignment_1_1() { return cSymbolAssignment_1_1; }

		//"+" | "-"
		public Alternatives getSymbolAlternatives_1_1_0() { return cSymbolAlternatives_1_1_0; }

		//"+"
		public Keyword getSymbolPlusSignKeyword_1_1_0_0() { return cSymbolPlusSignKeyword_1_1_0_0; }

		//"-"
		public Keyword getSymbolHyphenMinusKeyword_1_1_0_1() { return cSymbolHyphenMinusKeyword_1_1_0_1; }

		//right=Multiplication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_2_0() { return cRightMultiplicationParserRuleCall_1_2_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNumericalPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cSymbolAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cSymbolAlternatives_1_1_0 = (Alternatives)cSymbolAssignment_1_1.eContents().get(0);
		private final Keyword cSymbolAsteriskKeyword_1_1_0_0 = (Keyword)cSymbolAlternatives_1_1_0.eContents().get(0);
		private final Keyword cSymbolSolidusKeyword_1_1_0_1 = (Keyword)cSymbolAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightNumericalPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiplication returns NumericalProperty:
		//	NumericalPrimary ({Multiplication.left=current} symbol=("*" | "/") right=NumericalPrimary)*;
		@Override public ParserRule getRule() { return rule; }

		//NumericalPrimary ({Multiplication.left=current} symbol=("*" | "/") right=NumericalPrimary)*
		public Group getGroup() { return cGroup; }

		//NumericalPrimary
		public RuleCall getNumericalPrimaryParserRuleCall_0() { return cNumericalPrimaryParserRuleCall_0; }

		//({Multiplication.left=current} symbol=("*" | "/") right=NumericalPrimary)*
		public Group getGroup_1() { return cGroup_1; }

		//{Multiplication.left=current}
		public Action getMultiplicationLeftAction_1_0() { return cMultiplicationLeftAction_1_0; }

		//symbol=("*" | "/")
		public Assignment getSymbolAssignment_1_1() { return cSymbolAssignment_1_1; }

		//"*" | "/"
		public Alternatives getSymbolAlternatives_1_1_0() { return cSymbolAlternatives_1_1_0; }

		//"*"
		public Keyword getSymbolAsteriskKeyword_1_1_0_0() { return cSymbolAsteriskKeyword_1_1_0_0; }

		//"/"
		public Keyword getSymbolSolidusKeyword_1_1_0_1() { return cSymbolSolidusKeyword_1_1_0_1; }

		//right=NumericalPrimary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//NumericalPrimary
		public RuleCall getRightNumericalPrimaryParserRuleCall_1_2_0() { return cRightNumericalPrimaryParserRuleCall_1_2_0; }
	}

	public class NumericalPrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumericalPrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAtomicParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cNumericalPrimaryParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final RuleCall cVariableParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//NumericalPrimary returns NumericalProperty:
		//	NumberLiteral | Atomic | "(" NumericalPrimary ")" | Variable;
		@Override public ParserRule getRule() { return rule; }

		//NumberLiteral | Atomic | "(" NumericalPrimary ")" | Variable
		public Alternatives getAlternatives() { return cAlternatives; }

		//NumberLiteral
		public RuleCall getNumberLiteralParserRuleCall_0() { return cNumberLiteralParserRuleCall_0; }

		//Atomic
		public RuleCall getAtomicParserRuleCall_1() { return cAtomicParserRuleCall_1; }

		//"(" NumericalPrimary ")"
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//NumericalPrimary
		public RuleCall getNumericalPrimaryParserRuleCall_2_1() { return cNumericalPrimaryParserRuleCall_2_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }

		//Variable
		public RuleCall getVariableParserRuleCall_3() { return cVariableParserRuleCall_3; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Variable");
		private final Assignment cArgAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cArgIDTerminalRuleCall_0 = (RuleCall)cArgAssignment.eContents().get(0);
		
		//Variable:
		//	arg=ID;
		@Override public ParserRule getRule() { return rule; }

		//arg=ID
		public Assignment getArgAssignment() { return cArgAssignment; }

		//ID
		public RuleCall getArgIDTerminalRuleCall_0() { return cArgIDTerminalRuleCall_0; }
	}

	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumberLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDOUBLEParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//NumberLiteral:
		//	value=DOUBLE;
		@Override public ParserRule getRule() { return rule; }

		//value=DOUBLE
		public Assignment getValueAssignment() { return cValueAssignment; }

		//DOUBLE
		public RuleCall getValueDOUBLEParserRuleCall_0() { return cValueDOUBLEParserRuleCall_0; }
	}

	public class DOUBLEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DOUBLE");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//DOUBLE returns ecore::EDouble:
		//	"-"? INT ("." INT);
		@Override public ParserRule getRule() { return rule; }

		//"-"? INT ("." INT)
		public Group getGroup() { return cGroup; }

		//"-"?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }

		//"." INT
		public Group getGroup_2() { return cGroup_2; }

		//"."
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_2_1() { return cINTTerminalRuleCall_2_1; }
	}
	
	
	private final InputElements pInput;
	private final ProblemNoVarsElements pProblemNoVars;
	private final ProblemPropertyOptionalElements pProblemPropertyOptional;
	private final ProblemElements pProblem;
	private final ProblemColonElements pProblemColon;
	private final DeclarationElements pDeclaration;
	private final TypeElements pType;
	private final ImplicationElements pImplication;
	private final ORingElements pORing;
	private final ANDingElements pANDing;
	private final PrimaryElements pPrimary;
	private final GroupingElements pGrouping;
	private final NegationElements pNegation;
	private final QuantifierElements pQuantifier;
	private final AtomicElements pAtomic;
	private final BooleanLiteralElements pBooleanLiteral;
	private final TheoremElements pTheorem;
	private final AdditionElements pAddition;
	private final MultiplicationElements pMultiplication;
	private final NumericalPrimaryElements pNumericalPrimary;
	private final VariableElements pVariable;
	private final NumberLiteralElements pNumberLiteral;
	private final DOUBLEElements pDOUBLE;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public InputGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pInput = new InputElements();
		this.pProblemNoVars = new ProblemNoVarsElements();
		this.pProblemPropertyOptional = new ProblemPropertyOptionalElements();
		this.pProblem = new ProblemElements();
		this.pProblemColon = new ProblemColonElements();
		this.pDeclaration = new DeclarationElements();
		this.pType = new TypeElements();
		this.pImplication = new ImplicationElements();
		this.pORing = new ORingElements();
		this.pANDing = new ANDingElements();
		this.pPrimary = new PrimaryElements();
		this.pGrouping = new GroupingElements();
		this.pNegation = new NegationElements();
		this.pQuantifier = new QuantifierElements();
		this.pAtomic = new AtomicElements();
		this.pBooleanLiteral = new BooleanLiteralElements();
		this.pTheorem = new TheoremElements();
		this.pAddition = new AdditionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pNumericalPrimary = new NumericalPrimaryElements();
		this.pVariable = new VariableElements();
		this.pNumberLiteral = new NumberLiteralElements();
		this.pDOUBLE = new DOUBLEElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("algorithmMaker.Input".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////NOTE: Any changes to the formatting should be reflected with changes here.
	//Input:
	//	"Given" given=(ProblemPropertyOptional | ProblemNoVars) ";" (task=("Find" | "Count") goal=(Problem | ProblemNoVars))?
	//	(";" "Theorems:" theorems+=Theorem (";" theorems+=Theorem)* ";"?)?;
	public InputElements getInputAccess() {
		return pInput;
	}
	
	public ParserRule getInputRule() {
		return getInputAccess().getRule();
	}

	//ProblemNoVars returns Problem:
	//	property=Implication;
	public ProblemNoVarsElements getProblemNoVarsAccess() {
		return pProblemNoVars;
	}
	
	public ParserRule getProblemNoVarsRule() {
		return getProblemNoVarsAccess().getRule();
	}

	//ProblemPropertyOptional returns Problem:
	//	vars+=Declaration ("," vars+=Declaration)* ("st" property=Implication)?;
	public ProblemPropertyOptionalElements getProblemPropertyOptionalAccess() {
		return pProblemPropertyOptional;
	}
	
	public ParserRule getProblemPropertyOptionalRule() {
		return getProblemPropertyOptionalAccess().getRule();
	}

	//Problem:
	//	vars+=Declaration ("," vars+=Declaration)* "st" property=Implication;
	public ProblemElements getProblemAccess() {
		return pProblem;
	}
	
	public ParserRule getProblemRule() {
		return getProblemAccess().getRule();
	}

	//ProblemColon returns Problem:
	//	vars+=Declaration ("," vars+=Declaration)* ":" property=Implication;
	public ProblemColonElements getProblemColonAccess() {
		return pProblemColon;
	}
	
	public ParserRule getProblemColonRule() {
		return getProblemColonAccess().getRule();
	}

	//Declaration:
	//	type=Type? varName=ID;
	public DeclarationElements getDeclarationAccess() {
		return pDeclaration;
	}
	
	public ParserRule getDeclarationRule() {
		return getDeclarationAccess().getRule();
	}

	//Type:
	//	name=ID ("<" templateType=Type ">")?;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//Implication returns Property:
	//	ORing ({Implication.left=current} implication=("->" | "<-" | "<->") right=ORing)?;
	public ImplicationElements getImplicationAccess() {
		return pImplication;
	}
	
	public ParserRule getImplicationRule() {
		return getImplicationAccess().getRule();
	}

	//ORing returns Property:
	//	ANDing ({ORing.left=current} "|" right=ANDing)*;
	public ORingElements getORingAccess() {
		return pORing;
	}
	
	public ParserRule getORingRule() {
		return getORingAccess().getRule();
	}

	//ANDing returns Property:
	//	Primary ({ANDing.left=current} "&" right=Primary)*;
	public ANDingElements getANDingAccess() {
		return pANDing;
	}
	
	public ParserRule getANDingRule() {
		return getANDingAccess().getRule();
	}

	//Primary returns Property:
	//	Atomic | Quantifier | Grouping | BooleanLiteral | Negation;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}

	//Grouping returns Property:
	//	"(" Implication ")";
	public GroupingElements getGroupingAccess() {
		return pGrouping;
	}
	
	public ParserRule getGroupingRule() {
		return getGroupingAccess().getRule();
	}

	//Negation:
	//	"!" negated=Primary;
	public NegationElements getNegationAccess() {
		return pNegation;
	}
	
	public ParserRule getNegationRule() {
		return getNegationAccess().getRule();
	}

	//Quantifier:
	//	quantifier=("forall" | "exists") "(" subject=ProblemColon ")";
	public QuantifierElements getQuantifierAccess() {
		return pQuantifier;
	}
	
	public ParserRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}

	//Atomic:
	//	Function=ID "(" (args+=Addition ("," args+=Addition)*)? ")";
	public AtomicElements getAtomicAccess() {
		return pAtomic;
	}
	
	public ParserRule getAtomicRule() {
		return getAtomicAccess().getRule();
	}

	//BooleanLiteral:
	//	value=("TRUE" | "FALSE");
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return pBooleanLiteral;
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//Theorem:
	//	content=Implication ":::" Description=STRING;
	public TheoremElements getTheoremAccess() {
		return pTheorem;
	}
	
	public ParserRule getTheoremRule() {
		return getTheoremAccess().getRule();
	}

	//// **********Math things**********
	//Addition returns NumericalProperty:
	//	Multiplication ({Addition.left=current} symbol=("+" | "-") right=Multiplication)*;
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//Multiplication returns NumericalProperty:
	//	NumericalPrimary ({Multiplication.left=current} symbol=("*" | "/") right=NumericalPrimary)*;
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//NumericalPrimary returns NumericalProperty:
	//	NumberLiteral | Atomic | "(" NumericalPrimary ")" | Variable;
	public NumericalPrimaryElements getNumericalPrimaryAccess() {
		return pNumericalPrimary;
	}
	
	public ParserRule getNumericalPrimaryRule() {
		return getNumericalPrimaryAccess().getRule();
	}

	//Variable:
	//	arg=ID;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//NumberLiteral:
	//	value=DOUBLE;
	public NumberLiteralElements getNumberLiteralAccess() {
		return pNumberLiteral;
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}

	//DOUBLE returns ecore::EDouble:
	//	"-"? INT ("." INT);
	public DOUBLEElements getDOUBLEAccess() {
		return pDOUBLE;
	}
	
	public ParserRule getDOUBLERule() {
		return getDOUBLEAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
