/*
 * generated by Xtext
 */
package algorithmMaker.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class InputGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class InputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Input");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGivenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cGivenAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cGivenProblemParserRuleCall_1_0 = (RuleCall)cGivenAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cFindKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cGoalAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cGoalProblemParserRuleCall_4_0 = (RuleCall)cGoalAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Keyword cTheoremsKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Assignment cTheoremsAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cTheoremsTheoremParserRuleCall_5_2_0 = (RuleCall)cTheoremsAssignment_5_2.eContents().get(0);
		private final Group cGroup_5_3 = (Group)cGroup_5.eContents().get(3);
		private final Keyword cSemicolonKeyword_5_3_0 = (Keyword)cGroup_5_3.eContents().get(0);
		private final Assignment cTheoremsAssignment_5_3_1 = (Assignment)cGroup_5_3.eContents().get(1);
		private final RuleCall cTheoremsTheoremParserRuleCall_5_3_1_0 = (RuleCall)cTheoremsAssignment_5_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5_4 = (Keyword)cGroup_5.eContents().get(4);
		
		////TODO: Sugar: math signs, comparators
		////TODO: Sugar: implies "->, <-, <->" : relies on inline declarations...
		////TODO: Nested atomics??
		////NOTE: Any changes to the formatting should be reflected with changes here.
		//Input:
		//	"Given" given=Problem "," "Find" goal=Problem (";" "Theorems:" theorems+=Theorem (";" theorems+=Theorem)* ";"?)?;
		@Override public ParserRule getRule() { return rule; }

		//"Given" given=Problem "," "Find" goal=Problem (";" "Theorems:" theorems+=Theorem (";" theorems+=Theorem)* ";"?)?
		public Group getGroup() { return cGroup; }

		//"Given"
		public Keyword getGivenKeyword_0() { return cGivenKeyword_0; }

		//given=Problem
		public Assignment getGivenAssignment_1() { return cGivenAssignment_1; }

		//Problem
		public RuleCall getGivenProblemParserRuleCall_1_0() { return cGivenProblemParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//"Find"
		public Keyword getFindKeyword_3() { return cFindKeyword_3; }

		//goal=Problem
		public Assignment getGoalAssignment_4() { return cGoalAssignment_4; }

		//Problem
		public RuleCall getGoalProblemParserRuleCall_4_0() { return cGoalProblemParserRuleCall_4_0; }

		//(";" "Theorems:" theorems+=Theorem (";" theorems+=Theorem)* ";"?)?
		public Group getGroup_5() { return cGroup_5; }

		//";"
		public Keyword getSemicolonKeyword_5_0() { return cSemicolonKeyword_5_0; }

		//"Theorems:"
		public Keyword getTheoremsKeyword_5_1() { return cTheoremsKeyword_5_1; }

		//theorems+=Theorem
		public Assignment getTheoremsAssignment_5_2() { return cTheoremsAssignment_5_2; }

		//Theorem
		public RuleCall getTheoremsTheoremParserRuleCall_5_2_0() { return cTheoremsTheoremParserRuleCall_5_2_0; }

		//(";" theorems+=Theorem)*
		public Group getGroup_5_3() { return cGroup_5_3; }

		//";"
		public Keyword getSemicolonKeyword_5_3_0() { return cSemicolonKeyword_5_3_0; }

		//theorems+=Theorem
		public Assignment getTheoremsAssignment_5_3_1() { return cTheoremsAssignment_5_3_1; }

		//Theorem
		public RuleCall getTheoremsTheoremParserRuleCall_5_3_1_0() { return cTheoremsTheoremParserRuleCall_5_3_1_0; }

		//";"?
		public Keyword getSemicolonKeyword_5_4() { return cSemicolonKeyword_5_4; }
	}

	public class ProblemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Problem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cVarsAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cVarsIDTerminalRuleCall_0_0_0 = (RuleCall)cVarsAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cCommaKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cVarsAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cVarsIDTerminalRuleCall_0_1_1_0 = (RuleCall)cVarsAssignment_0_1_1.eContents().get(0);
		private final Keyword cStKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPropertyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPropertyORingParserRuleCall_2_0 = (RuleCall)cPropertyAssignment_2.eContents().get(0);
		
		//Problem:
		//	(vars+=ID ("," vars+=ID)*) "st" property=ORing;
		@Override public ParserRule getRule() { return rule; }

		//(vars+=ID ("," vars+=ID)*) "st" property=ORing
		public Group getGroup() { return cGroup; }

		//vars+=ID ("," vars+=ID)*
		public Group getGroup_0() { return cGroup_0; }

		//vars+=ID
		public Assignment getVarsAssignment_0_0() { return cVarsAssignment_0_0; }

		//ID
		public RuleCall getVarsIDTerminalRuleCall_0_0_0() { return cVarsIDTerminalRuleCall_0_0_0; }

		//("," vars+=ID)*
		public Group getGroup_0_1() { return cGroup_0_1; }

		//","
		public Keyword getCommaKeyword_0_1_0() { return cCommaKeyword_0_1_0; }

		//vars+=ID
		public Assignment getVarsAssignment_0_1_1() { return cVarsAssignment_0_1_1; }

		//ID
		public RuleCall getVarsIDTerminalRuleCall_0_1_1_0() { return cVarsIDTerminalRuleCall_0_1_1_0; }

		//"st"
		public Keyword getStKeyword_1() { return cStKeyword_1; }

		//property=ORing
		public Assignment getPropertyAssignment_2() { return cPropertyAssignment_2; }

		//ORing
		public RuleCall getPropertyORingParserRuleCall_2_0() { return cPropertyORingParserRuleCall_2_0; }
	}

	public class ORingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ORing");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cANDingParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cORingLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightANDingParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ORing returns Property:
		//	ANDing ({ORing.left=current} "|" right=ANDing)*;
		@Override public ParserRule getRule() { return rule; }

		//ANDing ({ORing.left=current} "|" right=ANDing)*
		public Group getGroup() { return cGroup; }

		//ANDing
		public RuleCall getANDingParserRuleCall_0() { return cANDingParserRuleCall_0; }

		//({ORing.left=current} "|" right=ANDing)*
		public Group getGroup_1() { return cGroup_1; }

		//{ORing.left=current}
		public Action getORingLeftAction_1_0() { return cORingLeftAction_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_1_1() { return cVerticalLineKeyword_1_1; }

		//right=ANDing
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ANDing
		public RuleCall getRightANDingParserRuleCall_1_2_0() { return cRightANDingParserRuleCall_1_2_0; }
	}

	public class ANDingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ANDing");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cANDingLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ANDing returns Property:
		//	Primary ({ANDing.left=current} "&" right=Primary)*;
		@Override public ParserRule getRule() { return rule; }

		//Primary ({ANDing.left=current} "&" right=Primary)*
		public Group getGroup() { return cGroup; }

		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }

		//({ANDing.left=current} "&" right=Primary)*
		public Group getGroup_1() { return cGroup_1; }

		//{ANDing.left=current}
		public Action getANDingLeftAction_1_0() { return cANDingLeftAction_1_0; }

		//"&"
		public Keyword getAmpersandKeyword_1_1() { return cAmpersandKeyword_1_1; }

		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}

	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomicParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQuantifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cORingParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//Primary returns Property:
		//	Atomic | Quantifier | "(" ORing ")";
		@Override public ParserRule getRule() { return rule; }

		//Atomic | Quantifier | "(" ORing ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//Atomic
		public RuleCall getAtomicParserRuleCall_0() { return cAtomicParserRuleCall_0; }

		//Quantifier
		public RuleCall getQuantifierParserRuleCall_1() { return cQuantifierParserRuleCall_1; }

		//"(" ORing ")"
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//ORing
		public RuleCall getORingParserRuleCall_2_1() { return cORingParserRuleCall_2_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class QuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Quantifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQuantifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cQuantifierAlternatives_0_0 = (Alternatives)cQuantifierAssignment_0.eContents().get(0);
		private final Keyword cQuantifierForallKeyword_0_0_0 = (Keyword)cQuantifierAlternatives_0_0.eContents().get(0);
		private final Keyword cQuantifierExistsKeyword_0_0_1 = (Keyword)cQuantifierAlternatives_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSubjectAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSubjectProblemParserRuleCall_2_0 = (RuleCall)cSubjectAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cPredicateAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPredicateORingParserRuleCall_4_0 = (RuleCall)cPredicateAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Quantifier:
		//	quantifier=("forall" | "exists") "(" subject=Problem ":" predicate=ORing ")";
		@Override public ParserRule getRule() { return rule; }

		//quantifier=("forall" | "exists") "(" subject=Problem ":" predicate=ORing ")"
		public Group getGroup() { return cGroup; }

		//quantifier=("forall" | "exists")
		public Assignment getQuantifierAssignment_0() { return cQuantifierAssignment_0; }

		//"forall" | "exists"
		public Alternatives getQuantifierAlternatives_0_0() { return cQuantifierAlternatives_0_0; }

		//"forall"
		public Keyword getQuantifierForallKeyword_0_0_0() { return cQuantifierForallKeyword_0_0_0; }

		//"exists"
		public Keyword getQuantifierExistsKeyword_0_0_1() { return cQuantifierExistsKeyword_0_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//subject=Problem
		public Assignment getSubjectAssignment_2() { return cSubjectAssignment_2; }

		//Problem
		public RuleCall getSubjectProblemParserRuleCall_2_0() { return cSubjectProblemParserRuleCall_2_0; }

		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }

		//predicate=ORing
		public Assignment getPredicateAssignment_4() { return cPredicateAssignment_4; }

		//ORing
		public RuleCall getPredicateORingParserRuleCall_4_0() { return cPredicateORingParserRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class AtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atomic");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFunctionIDTerminalRuleCall_0_0 = (RuleCall)cFunctionAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cArgsAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cArgsIDTerminalRuleCall_1_1_0_0 = (RuleCall)cArgsAssignment_1_1_0.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_1_0 = (Keyword)cGroup_1_1_1.eContents().get(0);
		private final Assignment cArgsAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final RuleCall cArgsIDTerminalRuleCall_1_1_1_1_0 = (RuleCall)cArgsAssignment_1_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//Atomic:
		//	Function=ID ("(" (args+=ID ("," args+=ID)*)? ")")?;
		@Override public ParserRule getRule() { return rule; }

		//Function=ID ("(" (args+=ID ("," args+=ID)*)? ")")?
		public Group getGroup() { return cGroup; }

		//Function=ID
		public Assignment getFunctionAssignment_0() { return cFunctionAssignment_0; }

		//ID
		public RuleCall getFunctionIDTerminalRuleCall_0_0() { return cFunctionIDTerminalRuleCall_0_0; }

		//("(" (args+=ID ("," args+=ID)*)? ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//(args+=ID ("," args+=ID)*)?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//args+=ID
		public Assignment getArgsAssignment_1_1_0() { return cArgsAssignment_1_1_0; }

		//ID
		public RuleCall getArgsIDTerminalRuleCall_1_1_0_0() { return cArgsIDTerminalRuleCall_1_1_0_0; }

		//("," args+=ID)*
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_1_0() { return cCommaKeyword_1_1_1_0; }

		//args+=ID
		public Assignment getArgsAssignment_1_1_1_1() { return cArgsAssignment_1_1_1_1; }

		//ID
		public RuleCall getArgsIDTerminalRuleCall_1_1_1_1_0() { return cArgsIDTerminalRuleCall_1_1_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class TheoremElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Theorem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRequirementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRequirementORingParserRuleCall_0_0 = (RuleCall)cRequirementAssignment_0.eContents().get(0);
		private final Keyword cColonHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cResultAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cResultORingParserRuleCall_2_0 = (RuleCall)cResultAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cCostAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCostINTTerminalRuleCall_4_0 = (RuleCall)cCostAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cDescriptionAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_6_0 = (RuleCall)cDescriptionAssignment_6.eContents().get(0);
		
		//Theorem:
		//	Requirement=ORing ":-" Result=ORing "," Cost=INT "," Description=STRING;
		@Override public ParserRule getRule() { return rule; }

		//Requirement=ORing ":-" Result=ORing "," Cost=INT "," Description=STRING
		public Group getGroup() { return cGroup; }

		//Requirement=ORing
		public Assignment getRequirementAssignment_0() { return cRequirementAssignment_0; }

		//ORing
		public RuleCall getRequirementORingParserRuleCall_0_0() { return cRequirementORingParserRuleCall_0_0; }

		//":-"
		public Keyword getColonHyphenMinusKeyword_1() { return cColonHyphenMinusKeyword_1; }

		//Result=ORing
		public Assignment getResultAssignment_2() { return cResultAssignment_2; }

		//ORing
		public RuleCall getResultORingParserRuleCall_2_0() { return cResultORingParserRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//Cost=INT
		public Assignment getCostAssignment_4() { return cCostAssignment_4; }

		//INT
		public RuleCall getCostINTTerminalRuleCall_4_0() { return cCostINTTerminalRuleCall_4_0; }

		//","
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }

		//Description=STRING
		public Assignment getDescriptionAssignment_6() { return cDescriptionAssignment_6; }

		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_6_0() { return cDescriptionSTRINGTerminalRuleCall_6_0; }
	}
	
	
	private final InputElements pInput;
	private final ProblemElements pProblem;
	private final ORingElements pORing;
	private final ANDingElements pANDing;
	private final PrimaryElements pPrimary;
	private final QuantifierElements pQuantifier;
	private final AtomicElements pAtomic;
	private final TheoremElements pTheorem;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public InputGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pInput = new InputElements();
		this.pProblem = new ProblemElements();
		this.pORing = new ORingElements();
		this.pANDing = new ANDingElements();
		this.pPrimary = new PrimaryElements();
		this.pQuantifier = new QuantifierElements();
		this.pAtomic = new AtomicElements();
		this.pTheorem = new TheoremElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("algorithmMaker.Input".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////TODO: Sugar: math signs, comparators
	////TODO: Sugar: implies "->, <-, <->" : relies on inline declarations...
	////TODO: Nested atomics??
	////NOTE: Any changes to the formatting should be reflected with changes here.
	//Input:
	//	"Given" given=Problem "," "Find" goal=Problem (";" "Theorems:" theorems+=Theorem (";" theorems+=Theorem)* ";"?)?;
	public InputElements getInputAccess() {
		return pInput;
	}
	
	public ParserRule getInputRule() {
		return getInputAccess().getRule();
	}

	//Problem:
	//	(vars+=ID ("," vars+=ID)*) "st" property=ORing;
	public ProblemElements getProblemAccess() {
		return pProblem;
	}
	
	public ParserRule getProblemRule() {
		return getProblemAccess().getRule();
	}

	//ORing returns Property:
	//	ANDing ({ORing.left=current} "|" right=ANDing)*;
	public ORingElements getORingAccess() {
		return pORing;
	}
	
	public ParserRule getORingRule() {
		return getORingAccess().getRule();
	}

	//ANDing returns Property:
	//	Primary ({ANDing.left=current} "&" right=Primary)*;
	public ANDingElements getANDingAccess() {
		return pANDing;
	}
	
	public ParserRule getANDingRule() {
		return getANDingAccess().getRule();
	}

	//Primary returns Property:
	//	Atomic | Quantifier | "(" ORing ")";
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}

	//Quantifier:
	//	quantifier=("forall" | "exists") "(" subject=Problem ":" predicate=ORing ")";
	public QuantifierElements getQuantifierAccess() {
		return pQuantifier;
	}
	
	public ParserRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}

	//Atomic:
	//	Function=ID ("(" (args+=ID ("," args+=ID)*)? ")")?;
	public AtomicElements getAtomicAccess() {
		return pAtomic;
	}
	
	public ParserRule getAtomicRule() {
		return getAtomicAccess().getRule();
	}

	//Theorem:
	//	Requirement=ORing ":-" Result=ORing "," Cost=INT "," Description=STRING;
	public TheoremElements getTheoremAccess() {
		return pTheorem;
	}
	
	public ParserRule getTheoremRule() {
		return getTheoremAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
