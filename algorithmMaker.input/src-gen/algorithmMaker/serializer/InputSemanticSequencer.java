/*
 * generated by Xtext
 */
package algorithmMaker.serializer;

import algorithmMaker.input.ANDing;
import algorithmMaker.input.Atomic;
import algorithmMaker.input.BooleanLiteral;
import algorithmMaker.input.Declaration;
import algorithmMaker.input.Input;
import algorithmMaker.input.InputPackage;
import algorithmMaker.input.Negation;
import algorithmMaker.input.NumberLiteral;
import algorithmMaker.input.ORing;
import algorithmMaker.input.Problem;
import algorithmMaker.input.ProblemShell;
import algorithmMaker.input.Quantifier;
import algorithmMaker.input.SugarAddition;
import algorithmMaker.input.SugarAtomic;
import algorithmMaker.input.SugarMultiplication;
import algorithmMaker.input.SugarVariable;
import algorithmMaker.input.Theorem;
import algorithmMaker.input.Type;
import algorithmMaker.services.InputGrammarAccess;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class InputSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private InputGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == InputPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case InputPackage.AN_DING:
				sequence_ANDing(context, (ANDing) semanticObject); 
				return; 
			case InputPackage.ATOMIC:
				sequence_Atomic(context, (Atomic) semanticObject); 
				return; 
			case InputPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case InputPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case InputPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case InputPackage.NEGATION:
				sequence_Negation(context, (Negation) semanticObject); 
				return; 
			case InputPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case InputPackage.ORING:
				sequence_ORing(context, (ORing) semanticObject); 
				return; 
			case InputPackage.PROBLEM:
				if(context == grammarAccess.getProblemNoVarsRule()) {
					sequence_ProblemNoVars(context, (Problem) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getProblemPropertyOptionalRule()) {
					sequence_ProblemPropertyOptional(context, (Problem) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getProblemRule()) {
					sequence_Problem(context, (Problem) semanticObject); 
					return; 
				}
				else break;
			case InputPackage.PROBLEM_SHELL:
				sequence_ProblemShell(context, (ProblemShell) semanticObject); 
				return; 
			case InputPackage.QUANTIFIER:
				sequence_Quantifier(context, (Quantifier) semanticObject); 
				return; 
			case InputPackage.SUGAR_ADDITION:
				sequence_SugarAddition(context, (SugarAddition) semanticObject); 
				return; 
			case InputPackage.SUGAR_ATOMIC:
				sequence_SugarAtomic(context, (SugarAtomic) semanticObject); 
				return; 
			case InputPackage.SUGAR_MULTIPLICATION:
				sequence_SugarMultiplication(context, (SugarMultiplication) semanticObject); 
				return; 
			case InputPackage.SUGAR_VARIABLE:
				sequence_SugarVariable(context, (SugarVariable) semanticObject); 
				return; 
			case InputPackage.THEOREM:
				sequence_Theorem(context, (Theorem) semanticObject); 
				return; 
			case InputPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (left=ANDing_ANDing_1_0 right=Primary)
	 */
	protected void sequence_ANDing(EObject context, ANDing semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputPackage.Literals.AN_DING__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputPackage.Literals.AN_DING__LEFT));
			if(transientValues.isValueTransient(semanticObject, InputPackage.Literals.AN_DING__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputPackage.Literals.AN_DING__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getANDingAccess().getANDingLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getANDingAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (Function=ID (args+=ID args+=ID*)?)
	 */
	protected void sequence_Atomic(EObject context, Atomic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value='TRUE' | value='FALSE')
	 */
	protected void sequence_BooleanLiteral(EObject context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type? varName=ID)
	 */
	protected void sequence_Declaration(EObject context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         given=ProblemPropertyOptional 
	 *         (((task='Find' | task='Count') goal=Problem) | (task='Test' (goal=Problem | goal=ProblemNoVars)))? 
	 *         (theorems+=Theorem theorems+=Theorem*)?
	 *     )
	 */
	protected void sequence_Input(EObject context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     negated=Primary
	 */
	protected void sequence_Negation(EObject context, Negation semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputPackage.Literals.NEGATION__NEGATED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputPackage.Literals.NEGATION__NEGATED));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNegationAccess().getNegatedPrimaryParserRuleCall_1_0(), semanticObject.getNegated());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_NumberLiteral(EObject context, NumberLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputPackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputPackage.Literals.NUMBER_LITERAL__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=ORing_ORing_1_0 right=ANDing)
	 */
	protected void sequence_ORing(EObject context, ORing semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputPackage.Literals.ORING__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputPackage.Literals.ORING__LEFT));
			if(transientValues.isValueTransient(semanticObject, InputPackage.Literals.ORING__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputPackage.Literals.ORING__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getORingAccess().getORingLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getORingAccess().getRightANDingParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     property=ORing
	 */
	protected void sequence_ProblemNoVars(EObject context, Problem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (vars+=Declaration vars+=Declaration* property=ORing?)
	 */
	protected void sequence_ProblemPropertyOptional(EObject context, Problem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     problem=Problem
	 */
	protected void sequence_ProblemShell(EObject context, ProblemShell semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputPackage.Literals.PROBLEM_SHELL__PROBLEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputPackage.Literals.PROBLEM_SHELL__PROBLEM));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProblemShellAccess().getProblemProblemParserRuleCall_1_0(), semanticObject.getProblem());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (vars+=Declaration vars+=Declaration* property=ORing)
	 */
	protected void sequence_Problem(EObject context, Problem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((quantifier='forall' | quantifier='exists') subject=Problem predicate=ORing)
	 */
	protected void sequence_Quantifier(EObject context, Quantifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=SugarAddition_SugarAddition_1_0 (symbol='+' | symbol='-') right=SugarMultiplication)
	 */
	protected void sequence_SugarAddition(EObject context, SugarAddition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (Function=ID (args+=SugarAddition args+=SugarAddition*)?)
	 */
	protected void sequence_SugarAtomic(EObject context, SugarAtomic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=SugarMultiplication_SugarMultiplication_1_0 (symbol='*' | symbol='/') right=SugarNumericalPrimary)
	 */
	protected void sequence_SugarMultiplication(EObject context, SugarMultiplication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     arg=ID
	 */
	protected void sequence_SugarVariable(EObject context, SugarVariable semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputPackage.Literals.SUGAR_VARIABLE__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputPackage.Literals.SUGAR_VARIABLE__ARG));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSugarVariableAccess().getArgIDTerminalRuleCall_0(), semanticObject.getArg());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         Requirement=ORing 
	 *         (Implication='->' | Implication='<-' | Implication='<->') 
	 *         Result=ORing 
	 *         Cost=INT 
	 *         Description=STRING 
	 *         PseudoCode=STRING?
	 *     )
	 */
	protected void sequence_Theorem(EObject context, Theorem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID templateType=Type?)
	 */
	protected void sequence_Type(EObject context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
