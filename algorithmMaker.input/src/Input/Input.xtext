grammar algorithmMaker.Input with org.eclipse.xtext.common.Terminals
//TODO: : comparators
//TODO: : implies "->, <-, <->" : relies on inline declarations?
//TODO: if get(x,i,xi) is used, test for index(x,i) automatically
//FIXME: Make  a separate syntactic artifact that can be completely removed after deing.
//		 The most prominent example of this is for nested atomics. The way these are done now is by allowing
//		 a general nested atomic input style. This is terrible. The core syntax just shouldn't allow this,
//		 but we should have a separate syntactic element that is only used in parsing which does allow it.
//		 Then when we de, we can get rid of it.
generate input "http://www.Input"

//NOTE: Any changes to the formatting should be reflected with changes here.
Input:
	'Given' given=ProblemPropertyOptional ';' (task=("Find" | "Count") goal=(Problem | ProblemNoVars))?
	(';' "Theorems:" theorems+=Theorem (';' theorems+=Theorem)* ';'?)?;

ProblemNoVars returns Problem:
	property=ORing;

ProblemPropertyOptional returns Problem:
	(vars+=Declaration) (',' vars+=Declaration)* ('st' property=ORing)?;

Problem:
	(vars+=Declaration) (',' vars+=Declaration)* 'st' property=ORing;

Declaration:
	(type=Type)? varName=ID;

Type:
	name=ID ('<' templateType=Type '>')?;

ORing returns Property:
	ANDing ({ORing.left=current} '|' right=ANDing)*;

ANDing returns Property:
	Primary ({ANDing.left=current} '&' right=Primary)*;

Primary returns Property:
	Atomic | Quantifier | ProblemShell | ('(' ORing ')') | BooleanLiteral | Negation;

ProblemShell:
	'{' problem=Problem '}';

Negation:
	'!' negated=Primary;

Quantifier:
	quantifier=('forall' | 'exists') '(' subject=Problem ':' predicate=ORing ')';

Atomic:
	Function=ID '(' (args+=Addition (',' args+=Addition)*)? ')';

BooleanLiteral:
	value=("TRUE" | "FALSE");

Theorem:
	Requirement=ORing
	Implication=("->" | "<-" | "<->")
	Result=ORing ',' Cost=INT ',' Description=STRING (',' PseudoCode=STRING)?;

	//**********Math things**********
Addition returns NumericalProperty:
	Multiplication ({Addition.left=current} symbol=('+' | '-') right=Multiplication)*;

Multiplication returns NumericalProperty:
	NumericalPrimary ({Multiplication.left=current} symbol=('*' | '/') right=NumericalPrimary)*;

NumericalPrimary returns NumericalProperty:
	NumberLiteral | Atomic | ('(' NumericalPrimary ')') | Variable;

Variable:
	arg=ID;

NumberLiteral:
	value=INT;
